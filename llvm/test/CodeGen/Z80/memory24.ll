; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=ez80 < %s | FileCheck %s --check-prefixes=EZ80

define i24 @load.p0i24(i24*) {
; EZ80-LABEL: load.p0i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld hl, (hl)
; EZ80-NEXT:    ret
  load i24, i24* %0
  ret i24 %2
}

define i24 @load.p0i24.1(i24*) {
; EZ80-LABEL: load.p0i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    ld hl, (hl)
; EZ80-NEXT:    ret
  load i24, i24* inttoptr (i1 1 to i24*)
  ret i24 %2
}

;define i24 @load.p1i24(i24 addrspace(1)*) {
;  load i24, i24 addrspace(1)* %0
;  ret i24 %2
;}

define i24 @load.p2i24(i24 addrspace(2)*) {
; EZ80-LABEL: load.p2i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc l
; EZ80-NEXT:    ld c, l
; EZ80-NEXT:    in d, (bc)
; EZ80-NEXT:    add a, 2
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (iy - 1), a
; EZ80-NEXT:    ld hl, (iy - 3)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    ret
  load i24, i24 addrspace(2)* %0
  ret i24 %2
}

define i24 @load.p2i24.1() {
; EZ80-LABEL: load.p2i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld l, 1
; EZ80-NEXT:    in a, (1)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ld c, l
; EZ80-NEXT:    inc c
; EZ80-NEXT:    in d, (bc)
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    add a, 2
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (iy - 1), a
; EZ80-NEXT:    ld hl, (iy - 3)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    ret
  load i24, i24 addrspace(2)* inttoptr (i1 1 to i24 addrspace(2)*)
  ret i24 %1
}

define i24 @load.p3i24(i24 addrspace(3)*) {
; EZ80-LABEL: load.p3i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    lea.sis hl, iy + 2
; EZ80-NEXT:    inc.sis iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    ld (ix - 1), l
; EZ80-NEXT:    ld hl, (ix - 3)
; EZ80-NEXT:    ld h, e
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i24, i24 addrspace(3)* %0
  ret i24 %2
}

define i24 @load.p3i24.1() {
; EZ80-LABEL: load.p3i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld iyl, 1
; EZ80-NEXT:    ld iyh, 0
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    lea.sis hl, iy + 2
; EZ80-NEXT:    inc.sis iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    ld (ix - 1), l
; EZ80-NEXT:    ld hl, (ix - 3)
; EZ80-NEXT:    ld h, e
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i24, i24 addrspace(3)* inttoptr (i1 1 to i24 addrspace(3)*)
  ret i24 %1
}

define i8 @load.p4i8(i8 addrspace(4)*) {
; EZ80-LABEL: load.p4i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ret
  load i8, i8 addrspace(4)* %0
  ret i8 %2
}

define i16 @load.p4i16(i16 addrspace(4)*) {
; EZ80-LABEL: load.p4i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld h, e
; EZ80-NEXT:    ret
  load i16, i16 addrspace(4)* %0
  ret i16 %2
}

define i24 @load.p4i24(i24 addrspace(4)*) {
; EZ80-LABEL: load.p4i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    lea hl, iy + 2
; EZ80-NEXT:    inc iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    ld (ix - 1), l
; EZ80-NEXT:    ld hl, (ix - 3)
; EZ80-NEXT:    ld h, e
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i24, i24 addrspace(4)* %0
  ret i24 %2
}

define i32 @load.p4i32(i32 addrspace(4)*) {
; EZ80-LABEL: load.p4i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    in d, (bc)
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    ld (ix - 1), l
; EZ80-NEXT:    ld hl, (ix - 3)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i32, i32 addrspace(4)* %0
  ret i32 %2
}

define i64 @load.p4i64(i64 addrspace(4)*) {
; EZ80-LABEL: load.p4i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    lea hl, ix - 6
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 3), a
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    in d, (bc)
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 4), a
; EZ80-NEXT:    lea bc, iy + 4
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 5), a
; EZ80-NEXT:    lea bc, iy + 5
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    lea bc, iy + 6
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 6), a
; EZ80-NEXT:    lea bc, iy + 7
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 2), l
; EZ80-NEXT:    ld hl, (ix - 4)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, (ix - 3) ; 1-byte Folded Reload
; EZ80-NEXT:    ld (ix - 1), e
; EZ80-NEXT:    ld de, (ix - 3)
; EZ80-NEXT:    ld d, (ix - 5) ; 1-byte Folded Reload
; EZ80-NEXT:    ld e, (ix - 4) ; 1-byte Folded Reload
; EZ80-NEXT:    ld c, (ix - 6) ; 1-byte Folded Reload
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i64, i64 addrspace(4)* %0
  ret i64 %2
}

define i8 @load.p4i8.1() {
; EZ80-LABEL: load.p4i8.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ret
  load i8, i8 addrspace(4)* inttoptr (i1 1 to i8 addrspace(4)*)
  ret i8 %1
}

define i16 @load.p4i16.1() {
; EZ80-LABEL: load.p4i16.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld h, e
; EZ80-NEXT:    ret
  load i16, i16 addrspace(4)* inttoptr (i1 1 to i16 addrspace(4)*)
  ret i16 %1
}

define i24 @load.p4i24.1() {
; EZ80-LABEL: load.p4i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    lea hl, iy + 2
; EZ80-NEXT:    inc iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    ld (ix - 1), l
; EZ80-NEXT:    ld hl, (ix - 3)
; EZ80-NEXT:    ld h, e
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i24, i24 addrspace(4)* inttoptr (i1 1 to i24 addrspace(4)*)
  ret i24 %1
}

define i32 @load.p4i32.1() {
; EZ80-LABEL: load.p4i32.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    dec sp
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    in d, (bc)
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    ld (ix - 1), l
; EZ80-NEXT:    ld hl, (ix - 3)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    inc sp
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i32, i32 addrspace(4)* inttoptr (i1 1 to i32 addrspace(4)*)
  ret i32 %1
}

define i64 @load.p4i64.1() {
; EZ80-LABEL: load.p4i64.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    lea hl, ix - 6
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 3), a
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    in d, (bc)
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    in l, (bc)
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 4), a
; EZ80-NEXT:    lea bc, iy + 4
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 5), a
; EZ80-NEXT:    lea bc, iy + 5
; EZ80-NEXT:    in e, (bc)
; EZ80-NEXT:    lea bc, iy + 6
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 6), a
; EZ80-NEXT:    lea bc, iy + 7
; EZ80-NEXT:    in a, (bc)
; EZ80-NEXT:    ld (ix - 2), l
; EZ80-NEXT:    ld hl, (ix - 4)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, (ix - 3) ; 1-byte Folded Reload
; EZ80-NEXT:    ld (ix - 1), e
; EZ80-NEXT:    ld de, (ix - 3)
; EZ80-NEXT:    ld d, (ix - 5) ; 1-byte Folded Reload
; EZ80-NEXT:    ld e, (ix - 4) ; 1-byte Folded Reload
; EZ80-NEXT:    ld c, (ix - 6) ; 1-byte Folded Reload
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  load i64, i64 addrspace(4)* inttoptr (i1 1 to i64 addrspace(4)*)
  ret i64 %1
}

define void @store.p0i24(i24, i24*) {
; EZ80-LABEL: store.p0i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld hl, (iy + 6)
; EZ80-NEXT:    ld (hl), de
; EZ80-NEXT:    ret
  store i24 %0, i24* %1
  ret void
}

;define void @store.p1i24(i24, i24 addrspace(1)*) {
;  store i24 %0, i24 addrspace(1)* %1
;  ret void
;}

define void @store.p2i24(i24, i24 addrspace(2)*) {
; EZ80-LABEL: store.p2i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld (iy - 3), de
; EZ80-NEXT:    ld l, (iy - 1)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    inc e
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    out (bc), h
; EZ80-NEXT:    add a, 2
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  store i24 %0, i24 addrspace(2)* %1
  ret void
}

define void @store.p2i24.1(i24) {
; EZ80-LABEL: store.p2i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld de, (ix + 6)
; EZ80-NEXT:    ld iyl, 1
; EZ80-NEXT:    ld (ix - 3), de
; EZ80-NEXT:    ld h, (ix - 1)
; EZ80-NEXT:    ld l, d
; EZ80-NEXT:    ld a, e
; EZ80-NEXT:    out (1), a
; EZ80-NEXT:    ld c, iyl
; EZ80-NEXT:    inc c
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    ld a, iyl
; EZ80-NEXT:    add a, 2
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    out (bc), h
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i24 %0, i24 addrspace(2)* inttoptr (i1 1 to i24 addrspace(2)*)
  ret void
}

define void @store.p3i24(i24, i24 addrspace(3)*) {
; EZ80-LABEL: store.p3i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld iy, (ix + 9)
; EZ80-NEXT:    ld (ix - 3), hl
; EZ80-NEXT:    ld a, (ix - 1)
; EZ80-NEXT:    ld e, h
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea.sis hl, iy + 2
; EZ80-NEXT:    inc.sis iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i24 %0, i24 addrspace(3)* %1
  ret void
}

define void @store.p3i24.1(i24) {
; EZ80-LABEL: store.p3i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld iyl, 1
; EZ80-NEXT:    ld iyh, 0
; EZ80-NEXT:    ld (ix - 3), hl
; EZ80-NEXT:    ld a, (ix - 1)
; EZ80-NEXT:    ld e, h
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea.sis hl, iy + 2
; EZ80-NEXT:    inc.sis iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i24 %0, i24 addrspace(3)* inttoptr (i1 1 to i24 addrspace(3)*)
  ret void
}

define void @store.p4i8(i8, i8 addrspace(4)*) {
; EZ80-LABEL: store.p4i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ret
  store i8 %0, i8 addrspace(4)* %1
  ret void
}

define void @store.p4i16(i16, i16 addrspace(4)*) {
; EZ80-LABEL: store.p4i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ld l, h
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    ret
  store i16 %0, i16 addrspace(4)* %1
  ret void
}

define void @store.p4i24(i24, i24 addrspace(4)*) {
; EZ80-LABEL: store.p4i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld iy, (ix + 9)
; EZ80-NEXT:    ld (ix - 3), hl
; EZ80-NEXT:    ld a, (ix - 1)
; EZ80-NEXT:    ld e, h
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea hl, iy + 2
; EZ80-NEXT:    inc iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i24 %0, i24 addrspace(4)* %1
  ret void
}

define void @store.p4i32(i32, i32 addrspace(4)*) {
; EZ80-LABEL: store.p4i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld (ix - 3), hl
; EZ80-NEXT:    ld e, (ix - 1)
; EZ80-NEXT:    ld d, h
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    out (bc), d
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i32 %0, i32 addrspace(4)* %1
  ret void
}

define void @store.p4i64(i64, i64 addrspace(4)*) {
; EZ80-LABEL: store.p4i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    lea hl, ix - 9
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ld bc, (ix + 6)
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    ld de, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld (ix - 8), e ; 1-byte Folded Spill
; EZ80-NEXT:    ld (ix - 7), d ; 1-byte Folded Spill
; EZ80-NEXT:    ld (ix - 6), hl
; EZ80-NEXT:    ld a, (ix - 4)
; EZ80-NEXT:    ld (ix - 9), a
; EZ80-NEXT:    ld e, h
; EZ80-NEXT:    ld d, l
; EZ80-NEXT:    ld (ix - 3), bc
; EZ80-NEXT:    ld l, (ix - 1)
; EZ80-NEXT:    ld h, b
; EZ80-NEXT:    ld a, c
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    out (bc), h
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    out (bc), d
; EZ80-NEXT:    lea bc, iy + 4
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    lea bc, iy + 5
; EZ80-NEXT:    ld a, (ix - 9)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    lea bc, iy + 6
; EZ80-NEXT:    ld a, (ix - 8)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    lea bc, iy + 7
; EZ80-NEXT:    ld a, (ix - 7)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i64 %0, i64 addrspace(4)* %1
  ret void
}

define void @store.p4i8.1(i8) {
; EZ80-LABEL: store.p4i8.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ret
  store i8 %0, i8 addrspace(4)* inttoptr (i1 1 to i8 addrspace(4)*)
  ret void
}

define void @store.p4i16.1(i16) {
; EZ80-LABEL: store.p4i16.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld a, e
; EZ80-NEXT:    ld l, d
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    ret
  store i16 %0, i16 addrspace(4)* inttoptr (i1 1 to i16 addrspace(4)*)
  ret void
}

define void @store.p4i24.1(i24) {
; EZ80-LABEL: store.p4i24.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld de, (ix + 6)
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    ld (ix - 3), hl
; EZ80-NEXT:    ld a, (ix - 1)
; EZ80-NEXT:    ld e, h
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea hl, iy + 2
; EZ80-NEXT:    inc iy
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i24 %0, i24 addrspace(4)* inttoptr (i1 1 to i24 addrspace(4)*)
  ret void
}

define void @store.p4i32.1(i32) {
; EZ80-LABEL: store.p4i32.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld de, (ix + 6)
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ld (ix - 3), de
; EZ80-NEXT:    ld l, (ix - 1)
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    out (bc), h
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i32 %0, i32 addrspace(4)* inttoptr (i1 1 to i32 addrspace(4)*)
  ret void
}

define void @store.p4i64.1(i64) {
; EZ80-LABEL: store.p4i64.1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    lea hl, ix - 9
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ld bc, 1
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ld hl, (ix + 12)
; EZ80-NEXT:    ld (ix - 8), l ; 1-byte Folded Spill
; EZ80-NEXT:    ld (ix - 7), h ; 1-byte Folded Spill
; EZ80-NEXT:    ld (ix - 6), de
; EZ80-NEXT:    ld a, (ix - 4)
; EZ80-NEXT:    ld (ix - 9), a
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld bc, (ix + 6)
; EZ80-NEXT:    ld (ix - 3), bc
; EZ80-NEXT:    ld e, (ix - 1)
; EZ80-NEXT:    ld d, b
; EZ80-NEXT:    ld a, c
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    inc bc
; EZ80-NEXT:    out (bc), d
; EZ80-NEXT:    lea bc, iy + 2
; EZ80-NEXT:    out (bc), e
; EZ80-NEXT:    lea bc, iy + 3
; EZ80-NEXT:    out (bc), l
; EZ80-NEXT:    lea bc, iy + 4
; EZ80-NEXT:    out (bc), h
; EZ80-NEXT:    lea bc, iy + 5
; EZ80-NEXT:    ld a, (ix - 9)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    lea bc, iy + 6
; EZ80-NEXT:    ld a, (ix - 8)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    lea bc, iy + 7
; EZ80-NEXT:    ld a, (ix - 7)
; EZ80-NEXT:    out (bc), a
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  store i64 %0, i64 addrspace(4)*  inttoptr (i1 1 to i64 addrspace(4)*)
  ret void
}

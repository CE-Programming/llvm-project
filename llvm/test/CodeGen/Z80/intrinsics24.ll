; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=ez80 < %s | FileCheck %s --check-prefixes=EZ80

declare i24 @llvm.abs.i24(i24, i1)
define i24 @abs.i24(i24) {
; EZ80-LABEL: abs.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    call __ixor
; EZ80-NEXT:    ret
  call i24 @llvm.abs.i24(i24 %0, i1 false)
  ret i24 %2
}

declare i24 @llvm.smax.i24(i24, i24)
define i24 @smax.i24(i24, i24) {
; EZ80-LABEL: smax.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld de, (ix + 6)
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    ld bc, -8388608
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, bc
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    jr c, BB1_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:  BB1_2:
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.smax.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.smin.i24(i24, i24)
define i24 @smin.i24(i24, i24) {
; EZ80-LABEL: smin.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld de, (ix + 6)
; EZ80-NEXT:    ld iy, (ix + 9)
; EZ80-NEXT:    ld bc, -8388608
; EZ80-NEXT:    add iy, bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    jr c, BB2_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:  BB2_2:
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.smin.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.umax.i24(i24, i24)
define i24 @umax.i24(i24, i24) {
; EZ80-LABEL: umax.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    jr c, BB3_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop bc
; EZ80-NEXT:  BB3_2:
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  call i24 @llvm.umax.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.umin.i24(i24, i24)
define i24 @umin.i24(i24, i24) {
; EZ80-LABEL: umin.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    jr c, BB4_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop de
; EZ80-NEXT:  BB4_2:
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    ret
  call i24 @llvm.umin.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare void @llvm.memcpy.p0i8.p0i8.i24(i8*, i8*, i24, i1)
define void @memcpy.p0i8.p0i8.i24(i8*, i8*, i24) {
; EZ80-LABEL: memcpy.p0i8.p0i8.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _memcpy
; EZ80-NEXT:    ld hl, 9
; EZ80-NEXT:    add hl, sp
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ret
  call void @llvm.memcpy.p0i8.p0i8.i24(i8* %0, i8* %1, i24 %2, i1 false)
  ret void
}

declare void @llvm.memcpy.inline.p0i8.p0i8.i24(i8*, i8*, i24, i1)
define void @memcpy.inline.p0i8.p0i8.i24(i8*, i8*) {
; EZ80-LABEL: memcpy.inline.p0i8.p0i8.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld hl, (iy + 6)
; EZ80-NEXT:    ld bc, 32
; EZ80-NEXT:    ldir
; EZ80-NEXT:    ret
  call void @llvm.memcpy.inline.p0i8.p0i8.i24(i8* %0, i8* %1, i24 32, i1 false)
  ret void
}

declare void @llvm.memmove.p0i8.p0i8.i24(i8*, i8*, i24, i1)
define void @memmove.p0i8.p0i8.i24(i8*, i8*, i24) {
; EZ80-LABEL: memmove.p0i8.p0i8.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _memmove
; EZ80-NEXT:    ld hl, 9
; EZ80-NEXT:    add hl, sp
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ret
  call void @llvm.memmove.p0i8.p0i8.i24(i8* %0, i8* %1, i24 %2, i1 false)
  ret void
}

declare void @llvm.memset.p0i8.i24(i8*, i8, i24, i1)
define void @memset.p0i8.i24(i8*, i8, i24) {
; EZ80-LABEL: memset.p0i8.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _memset
; EZ80-NEXT:    ld hl, 9
; EZ80-NEXT:    add hl, sp
; EZ80-NEXT:    ld sp, hl
; EZ80-NEXT:    ret
  call void @llvm.memset.p0i8.i24(i8* %0, i8 %1, i24 %2, i1 false)
  ret void
}

declare i24 @llvm.bitreverse.i24(i24)
define i24 @bitreverse.i24(i24) {
; EZ80-LABEL: bitreverse.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    call __ibitrev
; EZ80-NEXT:    ret
  call i24 @llvm.bitreverse.i24(i24 %0)
  ret i24 %2
}

declare i24 @llvm.ctpop.i24(i24)
define i24 @ctpop.i24(i24) {
; EZ80-LABEL: ctpop.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    call __ipopcnt
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  call i24 @llvm.ctpop.i24(i24 %0)
  ret i24 %2
}

declare i24 @llvm.ctlz.i24(i24)
define i24 @ctlz.i24(i24) {
; EZ80-LABEL: ctlz.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    jr nz, BB11_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld hl, 24
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB11_2: ; %cond.false
; EZ80-NEXT:    call __ictlz
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  call i24 @llvm.ctlz.i24(i24 %0)
  ret i24 %2
}

declare i24 @llvm.cttz.i24(i24)
define i24 @cttz.i24(i24) {
; EZ80-LABEL: cttz.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    jr nz, BB12_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld hl, 24
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB12_2: ; %cond.false
; EZ80-NEXT:    scf
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    dec bc
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    call __ipopcnt
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  call i24 @llvm.cttz.i24(i24 %0)
  ret i24 %2
}

declare i24 @llvm.fshl.i24(i24, i24, i24)
define i24 @fshl.i24(i24, i24, i24) {
; EZ80-LABEL: fshl.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 12)
; EZ80-NEXT:    ld bc, 23
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __ishl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    ld bc, 23
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __ishru
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    call __ior
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.fshl.i24(i24 %0, i24 %1, i24 %2)
  ret i24 %4
}

declare i24 @llvm.fshr.i24(i24, i24, i24)
define i24 @fshr.i24(i24, i24, i24) {
; EZ80-LABEL: fshr.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 9)
; EZ80-NEXT:    ld de, (ix + 12)
; EZ80-NEXT:    ld bc, 23
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __ishru
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    ld bc, 23
; EZ80-NEXT:    call __iand
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __ishl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    call __ior
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.fshr.i24(i24 %0, i24 %1, i24 %2)
  ret i24 %4
}

declare {i24, i1} @llvm.sadd.with.overflow.i24(i24, i24)
define i1 @sadd.with.overflow.i24(i24, i24) {
; EZ80-LABEL: sadd.with.overflow.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    add hl, de
; EZ80-NEXT:    jp pe, BB15_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld a, 0
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB15_2:
; EZ80-NEXT:    ld a, -1
; EZ80-NEXT:    ret
  call {i24, i1} @llvm.sadd.with.overflow.i24(i24 %0, i24 %1)
  extractvalue {i24, i1} %3, 1
  ret i1 %4
}

declare {i24, i1} @llvm.uadd.with.overflow.i24(i24, i24)
define i1 @uadd.with.overflow.i24(i24, i24) {
; EZ80-LABEL: uadd.with.overflow.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    add hl, de
; EZ80-NEXT:    ; kill: def $a killed $a
; EZ80-NEXT:    sbc a, a
; EZ80-NEXT:    ret
  call {i24, i1} @llvm.uadd.with.overflow.i24(i24 %0, i24 %1)
  extractvalue {i24, i1} %3, 1
  ret i1 %4
}

declare {i24, i1} @llvm.ssub.with.overflow.i24(i24, i24)
define i1 @ssub.with.overflow.i24(i24, i24) {
; EZ80-LABEL: ssub.with.overflow.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    jp pe, BB17_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld a, 0
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB17_2:
; EZ80-NEXT:    ld a, -1
; EZ80-NEXT:    ret
  call {i24, i1} @llvm.ssub.with.overflow.i24(i24 %0, i24 %1)
  extractvalue {i24, i1} %3, 1
  ret i1 %4
}

declare {i24, i1} @llvm.usub.with.overflow.i24(i24, i24)
define i1 @usub.with.overflow.i24(i24, i24) {
; EZ80-LABEL: usub.with.overflow.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    ; kill: def $a killed $a
; EZ80-NEXT:    sbc a, a
; EZ80-NEXT:    ret
  call {i24, i1} @llvm.usub.with.overflow.i24(i24 %0, i24 %1)
  extractvalue {i24, i1} %3, 1
  ret i1 %4
}

declare i24 @llvm.sadd.sat.i24(i24, i24)
define i24 @sadd.sat.i24(i24, i24) {
; EZ80-LABEL: sadd.sat.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ld (ix - 3), hl
; EZ80-NEXT:    add hl, de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld bc, -8388608
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    ld iy, (ix - 3)
; EZ80-NEXT:    ld bc, (ix + 9)
; EZ80-NEXT:    add iy, bc
; EZ80-NEXT:    jp pe, BB19_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:  BB19_2:
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.sadd.sat.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.uadd.sat.i24(i24, i24)
define i24 @uadd.sat.i24(i24, i24) {
; EZ80-LABEL: uadd.sat.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    ld bc, (ix + 9)
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    add hl, bc
; EZ80-NEXT:    ld de, -1
; EZ80-NEXT:    add iy, bc
; EZ80-NEXT:    jr c, BB20_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:  BB20_2:
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.uadd.sat.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.ssub.sat.i24(i24, i24)
define i24 @ssub.sat.i24(i24, i24) {
; EZ80-LABEL: ssub.sat.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld de, (ix + 6)
; EZ80-NEXT:    ld bc, (ix + 9)
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ld (ix - 3), iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ld bc, -8388608
; EZ80-NEXT:    add iy, bc
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    jp pe, BB21_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld iy, (ix - 3)
; EZ80-NEXT:  BB21_2:
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.ssub.sat.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.usub.sat.i24(i24, i24)
define i24 @usub.sat.i24(i24, i24) {
; EZ80-LABEL: usub.sat.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ld bc, 0
; EZ80-NEXT:    or a, a
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    jr c, BB22_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    lea bc, iy
; EZ80-NEXT:  BB22_2:
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call i24 @llvm.usub.sat.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.smul.sat.i24(i24, i24)
define i24 @smul.sat.i24(i24, i24) {
; EZ80-LABEL: smul.sat.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _llvm.smul.sat.i24
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i24 @llvm.smul.sat.i24(i24 %0, i24 %1)
  ret i24 %3
}

declare i24 @llvm.umul.sat.i24(i24, i24)
define i24 @umul.sat.i24(i24, i24) {
; EZ80-LABEL: umul.sat.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _llvm.umul.sat.i24
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i24 @llvm.umul.sat.i24(i24 %0, i24 %1)
  ret i24 %3
}

; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=z80 < %s | FileCheck %s --check-prefixes=Z80
; RUN: llc -mtriple=ez80-code16 < %s | FileCheck %s --check-prefixes=EZ80-CODE16
; RUN: llc -mtriple=ez80 < %s | FileCheck %s --check-prefixes=EZ80

declare float @llvm.sqrt.f32(float)
define float @sqrt.f32(float) {
; Z80-LABEL: sqrt.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _sqrtf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sqrt.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _sqrtf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sqrt.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _sqrtf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.sqrt.f32(float %0)
  ret float %2
}
declare double @llvm.sqrt.f64(double)
define double @sqrt.f64(double) {
; Z80-LABEL: sqrt.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _sqrt
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sqrt.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _sqrt
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sqrt.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _sqrt
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.sqrt.f64(double %0)
  ret double %2
}

declare float @llvm.powi.f32.i8(float, i8)
define float @powi.f32.i8(float, i8) {
; Z80-LABEL: powi.f32.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld b, a
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    call __ltof
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _powf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f32.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld l, (ix + 8)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld b, a
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _powf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f32.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld e, (ix + 9)
; EZ80-NEXT:    ld a, (ix + 12)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _powf
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call float @llvm.powi.f32.i8(float %0, i8 %1)
  ret float %3
}
declare double @llvm.powi.f64.i8(double, i8)
define double @powi.f64.i8(double, i8) {
; Z80-LABEL: powi.f64.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld b, a
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    call __ltod
; Z80-NEXT:    push iy
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _pow
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f64.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld l, (ix + 12)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld b, a
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _pow
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f64.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld a, (ix + 15)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ; kill: def $bc killed $bc def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 12)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _pow
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.powi.f64.i8(double %0, i8 %1)
  ret double %3
}
declare float @llvm.powi.f32.i16(float, i16)
define float @powi.f32.i16(float, i16) {
; Z80-LABEL: powi.f32.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    call __ltof
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _powf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f32.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _powf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f32.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld de, (ix + 12)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _powf
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call float @llvm.powi.f32.i16(float %0, i16 %1)
  ret float %3
}
declare double @llvm.powi.f64.i16(double, i16)
define double @powi.f64.i16(double, i16) {
; Z80-LABEL: powi.f64.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld c, (ix + 12)
; Z80-NEXT:    ld b, (ix + 13)
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    call __ltod
; Z80-NEXT:    push iy
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _pow
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f64.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld bc, (ix + 12)
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _pow
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f64.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld de, (ix + 15)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ; kill: def $bc killed $bc def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 12)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _pow
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.powi.f64.i16(double %0, i16 %1)
  ret double %3
}
declare float @llvm.powi.f32.i32(float, i32)
define float @powi.f32.i32(float, i32) {
; Z80-LABEL: powi.f32.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ltof
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _powf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f32.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _powf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f32.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    ld e, (ix + 9)
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld a, (ix + 15)
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push iy
; EZ80-NEXT:    call _powf
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call float @llvm.powi.f32.i32(float %0, i32 %1)
  ret float %3
}
declare double @llvm.powi.f64.i32(double, i32)
define double @powi.f64.i32(double, i32) {
; Z80-LABEL: powi.f64.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ld e, (ix + 14)
; Z80-NEXT:    ld d, (ix + 15)
; Z80-NEXT:    call __ltod
; Z80-NEXT:    push iy
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _pow
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f64.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    ld de, (ix + 14)
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _pow
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f64.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld hl, (ix + 15)
; EZ80-NEXT:    ld e, (ix + 18)
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ; kill: def $bc killed $bc def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _pow
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.powi.f64.i32(double %0, i32 %1)
  ret double %3
}
declare float @llvm.powi.f32.i64(float, i64)
define float @powi.f32.i64(float, i64) {
; Z80-LABEL: powi.f32.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    ld c, (ix + 12)
; Z80-NEXT:    ld b, (ix + 13)
; Z80-NEXT:    ld l, (ix + 14)
; Z80-NEXT:    ld h, (ix + 15)
; Z80-NEXT:    push hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, iyl
; Z80-NEXT:    ld d, iyh
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    call __lltof
; Z80-NEXT:    pop bc
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _powf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f32.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    ld bc, (ix + 12)
; EZ80-CODE16-NEXT:    ld hl, (ix + 14)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    lea hl, iy
; EZ80-CODE16-NEXT:    call __lltof
; EZ80-CODE16-NEXT:    pop bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _powf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f32.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld hl, (ix + 12)
; EZ80-NEXT:    ld de, (ix + 15)
; EZ80-NEXT:    ld bc, (ix + 18)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lltof
; EZ80-NEXT:    ; kill: def $e killed $e def $ude
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push iy
; EZ80-NEXT:    call _powf
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call float @llvm.powi.f32.i64(float %0, i64 %1)
  ret float %3
}
declare double @llvm.powi.f64.i64(double, i64)
define double @powi.f64.i64(double, i64) {
; Z80-LABEL: powi.f64.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ld e, (ix + 14)
; Z80-NEXT:    ld d, (ix + 15)
; Z80-NEXT:    ld c, (ix + 16)
; Z80-NEXT:    ld b, (ix + 17)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __lltod
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    push iy
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _pow
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: powi.f64.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    ld de, (ix + 14)
; EZ80-CODE16-NEXT:    ld bc, (ix + 16)
; EZ80-CODE16-NEXT:    ld iy, (ix + 18)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __lltod
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    pop hl
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _pow
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: powi.f64.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld hl, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld bc, (ix + 21)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lltod
; EZ80-NEXT:    ; kill: def $bc killed $bc def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _pow
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.powi.f64.i64(double %0, i64 %1)
  ret double %3
}

declare float @llvm.sin.f32(float)
define float @sin.f32(float) {
; Z80-LABEL: sin.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _sinf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sin.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _sinf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sin.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _sinf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.sin.f32(float %0)
  ret float %2
}
declare double @llvm.sin.f64(double)
define double @sin.f64(double) {
; Z80-LABEL: sin.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _sin
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sin.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _sin
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sin.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _sin
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.sin.f64(double %0)
  ret double %2
}

declare float @llvm.cos.f32(float)
define float @cos.f32(float) {
; Z80-LABEL: cos.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _cosf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: cos.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _cosf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: cos.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _cosf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.cos.f32(float %0)
  ret float %2
}
declare double @llvm.cos.f64(double)
define double @cos.f64(double) {
; Z80-LABEL: cos.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _cos
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: cos.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _cos
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: cos.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _cos
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.cos.f64(double %0)
  ret double %2
}

declare float @llvm.pow.f32(float, float)
define float @pow.f32(float, float) {
; Z80-LABEL: pow.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _powf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: pow.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _powf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: pow.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    ld c, (iy + 12)
; EZ80-NEXT:    ; kill: def $c killed $c def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _powf
; EZ80-NEXT:    ld iy, 12
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.pow.f32(float %0, float %1)
  ret float %3
}
declare double @llvm.pow.f64(double, double)
define double @pow.f64(double, double) {
; Z80-LABEL: pow.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _pow
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: pow.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _pow
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: pow.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _pow
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.pow.f64(double %0, double %1)
  ret double %3
}

declare float @llvm.exp.f32(float)
define float @exp.f32(float) {
; Z80-LABEL: exp.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _expf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: exp.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _expf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: exp.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _expf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.exp.f32(float %0)
  ret float %2
}
declare double @llvm.exp.f64(double)
define double @exp.f64(double) {
; Z80-LABEL: exp.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _exp
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: exp.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _exp
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: exp.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _exp
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.exp.f64(double %0)
  ret double %2
}

declare float @llvm.exp2.f32(float)
define float @exp2.f32(float) {
; Z80-LABEL: exp2.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _exp2f
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: exp2.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _exp2f
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: exp2.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _exp2f
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.exp2.f32(float %0)
  ret float %2
}
declare double @llvm.exp2.f64(double)
define double @exp2.f64(double) {
; Z80-LABEL: exp2.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _exp2
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: exp2.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _exp2
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: exp2.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _exp2
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.exp2.f64(double %0)
  ret double %2
}

declare float @llvm.log.f32(float)
define float @log.f32(float) {
; Z80-LABEL: log.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _logf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: log.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _logf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: log.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _logf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.log.f32(float %0)
  ret float %2
}
declare double @llvm.log.f64(double)
define double @log.f64(double) {
; Z80-LABEL: log.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _log
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: log.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _log
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: log.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _log
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.log.f64(double %0)
  ret double %2
}

declare float @llvm.log10.f32(float)
define float @log10.f32(float) {
; Z80-LABEL: log10.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _log10f
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: log10.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _log10f
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: log10.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _log10f
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.log10.f32(float %0)
  ret float %2
}
declare double @llvm.log10.f64(double)
define double @log10.f64(double) {
; Z80-LABEL: log10.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _log10
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: log10.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _log10
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: log10.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _log10
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.log10.f64(double %0)
  ret double %2
}

declare float @llvm.log2.f32(float)
define float @log2.f32(float) {
; Z80-LABEL: log2.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _log2f
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: log2.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _log2f
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: log2.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _log2f
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.log2.f32(float %0)
  ret float %2
}
declare double @llvm.log2.f64(double)
define double @log2.f64(double) {
; Z80-LABEL: log2.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _log2
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: log2.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _log2
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: log2.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _log2
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.log2.f64(double %0)
  ret double %2
}

declare float @llvm.fma.f32(float, float, float)
define float @fma.f32(float, float, float) {
; Z80-LABEL: fma.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 10)
; Z80-NEXT:    ld b, (ix + 11)
; Z80-NEXT:    ld e, (ix + 12)
; Z80-NEXT:    ld d, (ix + 13)
; Z80-NEXT:    ld l, (ix + 14)
; Z80-NEXT:    ld h, (ix + 15)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fmaf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fma.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 8)
; EZ80-CODE16-NEXT:    ld bc, (ix + 10)
; EZ80-CODE16-NEXT:    ld de, (ix + 12)
; EZ80-CODE16-NEXT:    ld hl, (ix + 14)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fmaf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fma.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld de, (ix + 12)
; EZ80-NEXT:    ld c, (ix + 15)
; EZ80-NEXT:    ld hl, (ix + 18)
; EZ80-NEXT:    ld b, (ix + 21)
; EZ80-NEXT:    ld iyl, b
; EZ80-NEXT:    push iy
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld l, c
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmaf
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call float @llvm.fma.f32(float %0, float %1, float %2)
  ret float %4
}
declare double @llvm.fma.f64(double, double, double)
define double @fma.f64(double, double, double) {
; Z80-LABEL: fma.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 20)
; Z80-NEXT:    ld h, (ix + 21)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 22)
; Z80-NEXT:    ld b, (ix + 23)
; Z80-NEXT:    ld e, (ix + 24)
; Z80-NEXT:    ld d, (ix + 25)
; Z80-NEXT:    ld l, (ix + 26)
; Z80-NEXT:    ld h, (ix + 27)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 16)
; Z80-NEXT:    ld h, (ix + 17)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 14)
; Z80-NEXT:    ld h, (ix + 15)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fma
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 24
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fma.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 20)
; EZ80-CODE16-NEXT:    ld bc, (ix + 22)
; EZ80-CODE16-NEXT:    ld de, (ix + 24)
; EZ80-CODE16-NEXT:    ld hl, (ix + 26)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 16)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 14)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fma
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 24
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fma.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 21)
; EZ80-NEXT:    ld bc, (ix + 24)
; EZ80-NEXT:    ld de, (ix + 27)
; EZ80-NEXT:    ld hl, (ix + 30)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 18)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 15)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 12)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fma
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.fma.f64(double %0, double %1, double %2)
  ret double %4
}

declare float @llvm.fabs.f32(float)
define float @fabs.f32(float) {
; Z80-LABEL: fabs.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fabsf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fabs.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fabsf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fabs.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fabsf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.fabs.f32(float %0)
  ret float %2
}
declare double @llvm.fabs.f64(double)
define double @fabs.f64(double) {
; Z80-LABEL: fabs.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _fabs
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fabs.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _fabs
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fabs.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fabs
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.fabs.f64(double %0)
  ret double %2
}

declare float @llvm.minnum.f32(float, float)
define float @minnum.f32(float, float) {
; Z80-LABEL: minnum.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _fminf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: minnum.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _fminf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: minnum.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    ld c, (iy + 12)
; EZ80-NEXT:    ; kill: def $c killed $c def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fminf
; EZ80-NEXT:    ld iy, 12
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.minnum.f32(float %0, float %1)
  ret float %3
}
declare double @llvm.minnum.f64(double, double)
define double @minnum.f64(double, double) {
; Z80-LABEL: minnum.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fmin
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: minnum.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fmin
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: minnum.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmin
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.minnum.f64(double %0, double %1)
  ret double %3
}

declare float @llvm.maxnum.f32(float, float)
define float @maxnum.f32(float, float) {
; Z80-LABEL: maxnum.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _fmaxf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: maxnum.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _fmaxf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: maxnum.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    ld c, (iy + 12)
; EZ80-NEXT:    ; kill: def $c killed $c def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmaxf
; EZ80-NEXT:    ld iy, 12
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.maxnum.f32(float %0, float %1)
  ret float %3
}
declare double @llvm.maxnum.f64(double, double)
define double @maxnum.f64(double, double) {
; Z80-LABEL: maxnum.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fmax
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: maxnum.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fmax
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: maxnum.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmax
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.maxnum.f64(double %0, double %1)
  ret double %3
}

declare float @llvm.minimum.f32(float, float)
define float @minimum.f32(float, float) {
; Z80-LABEL: minimum.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _fminf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: minimum.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _fminf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: minimum.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    ld c, (iy + 12)
; EZ80-NEXT:    ; kill: def $c killed $c def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fminf
; EZ80-NEXT:    ld iy, 12
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.minnum.f32(float %0, float %1)
  ret float %3
}
declare double @llvm.minimum.f64(double, double)
define double @minimum.f64(double, double) {
; Z80-LABEL: minimum.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fmin
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: minimum.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fmin
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: minimum.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmin
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.minnum.f64(double %0, double %1)
  ret double %3
}

declare float @llvm.maximum.f32(float, float)
define float @maximum.f32(float, float) {
; Z80-LABEL: maximum.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _fmaxf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: maximum.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _fmaxf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: maximum.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    ld c, (iy + 12)
; EZ80-NEXT:    ; kill: def $c killed $c def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmaxf
; EZ80-NEXT:    ld iy, 12
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.maxnum.f32(float %0, float %1)
  ret float %3
}
declare double @llvm.maximum.f64(double, double)
define double @maximum.f64(double, double) {
; Z80-LABEL: maximum.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _fmax
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: maximum.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _fmax
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: maximum.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _fmax
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.maxnum.f64(double %0, double %1)
  ret double %3
}

declare float @llvm.copysign.f32(float, float)
define float @copysign.f32(float, float) {
; Z80-LABEL: copysign.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _copysignf
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: copysign.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _copysignf
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: copysign.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, (iy + 9)
; EZ80-NEXT:    ld c, (iy + 12)
; EZ80-NEXT:    ; kill: def $c killed $c def $ubc
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _copysignf
; EZ80-NEXT:    ld iy, 12
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.copysign.f32(float %0, float %1)
  ret float %3
}
declare double @llvm.copysign.f64(double, double)
define double @copysign.f64(double, double) {
; Z80-LABEL: copysign.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    call _copysign
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 16
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: copysign.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _copysign
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 16
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: copysign.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _copysign
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.copysign.f64(double %0, double %1)
  ret double %3
}

declare float @llvm.floor.f32(float)
define float @floor.f32(float) {
; Z80-LABEL: floor.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _floorf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: floor.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _floorf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: floor.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _floorf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.floor.f32(float %0)
  ret float %2
}
declare double @llvm.floor.f64(double)
define double @floor.f64(double) {
; Z80-LABEL: floor.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _floor
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: floor.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _floor
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: floor.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _floor
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.floor.f64(double %0)
  ret double %2
}

declare float @llvm.ceil.f32(float)
define float @ceil.f32(float) {
; Z80-LABEL: ceil.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _ceilf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ceil.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _ceilf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ceil.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _ceilf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.ceil.f32(float %0)
  ret float %2
}
declare double @llvm.ceil.f64(double)
define double @ceil.f64(double) {
; Z80-LABEL: ceil.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _ceil
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ceil.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _ceil
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ceil.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _ceil
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.ceil.f64(double %0)
  ret double %2
}

declare float @llvm.trunc.f32(float)
define float @trunc.f32(float) {
; Z80-LABEL: trunc.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _truncf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _truncf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _truncf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.trunc.f32(float %0)
  ret float %2
}
declare double @llvm.trunc.f64(double)
define double @trunc.f64(double) {
; Z80-LABEL: trunc.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _trunc
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _trunc
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _trunc
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.trunc.f64(double %0)
  ret double %2
}

declare float @llvm.rint.f32(float)
define float @rint.f32(float) {
; Z80-LABEL: rint.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _rintf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: rint.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _rintf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: rint.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _rintf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.rint.f32(float %0)
  ret float %2
}
declare double @llvm.rint.f64(double)
define double @rint.f64(double) {
; Z80-LABEL: rint.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _rint
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: rint.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _rint
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: rint.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _rint
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.rint.f64(double %0)
  ret double %2
}

declare float @llvm.nearbyint.f32(float)
define float @nearbyint.f32(float) {
; Z80-LABEL: nearbyint.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _nearbyintf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: nearbyint.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _nearbyintf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: nearbyint.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _nearbyintf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.nearbyint.f32(float %0)
  ret float %2
}
declare double @llvm.nearbyint.f64(double)
define double @nearbyint.f64(double) {
; Z80-LABEL: nearbyint.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _nearbyint
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: nearbyint.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _nearbyint
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: nearbyint.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _nearbyint
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.nearbyint.f64(double %0)
  ret double %2
}

declare float @llvm.round.f32(float)
define float @round.f32(float) {
; Z80-LABEL: round.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _roundf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: round.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _roundf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: round.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _roundf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.round.f32(float %0)
  ret float %2
}
declare double @llvm.round.f64(double)
define double @round.f64(double) {
; Z80-LABEL: round.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _round
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: round.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _round
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: round.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _round
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.round.f64(double %0)
  ret double %2
}

declare float @llvm.roundeven.f32(float)
define float @roundeven.f32(float) {
; Z80-LABEL: roundeven.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _roundevenf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: roundeven.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _roundevenf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: roundeven.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _roundevenf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call float @llvm.roundeven.f32(float %0)
  ret float %2
}
declare double @llvm.roundeven.f64(double)
define double @roundeven.f64(double) {
; Z80-LABEL: roundeven.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    push bc
; Z80-NEXT:    push de
; Z80-NEXT:    push iy
; Z80-NEXT:    call _roundeven
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 8
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: roundeven.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call _roundeven
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 8
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: roundeven.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _roundeven
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call double @llvm.roundeven.f64(double %0)
  ret double %2
}

declare i32 @llvm.lround.i32.f32(float)
define i32 @lround.i32.f32(float) {
; Z80-LABEL: lround.i32.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _lroundf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lround.i32.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _lroundf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lround.i32.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _lroundf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i32 @llvm.lround.i32.f32(float %0)
  ret i32 %2
}
declare i32 @llvm.lround.i32.f64(float)
define i32 @lround.i32.f64(float) {
; Z80-LABEL: lround.i32.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _lroundf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lround.i32.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _lroundf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lround.i32.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _lroundf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i32 @llvm.lround.i32.f64(float %0)
  ret i32 %2
}

declare i64 @llvm.llround.i64.f32(float)
define i64 @llround.i64.f32(float) {
; Z80-LABEL: llround.i64.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _llround
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: llround.i64.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _llround
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: llround.i64.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _llround
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i64 @llvm.llround.i64.f32(float %0)
  ret i64 %2
}
declare i64 @llvm.llround.i64.f64(float)
define i64 @llround.i64.f64(float) {
; Z80-LABEL: llround.i64.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _llround
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: llround.i64.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _llround
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: llround.i64.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _llround
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i64 @llvm.llround.i64.f64(float %0)
  ret i64 %2
}

declare i32 @llvm.lrint.i32.f32(float)
define i32 @lrint.i32.f32(float) {
; Z80-LABEL: lrint.i32.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _lrintf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lrint.i32.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _lrintf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lrint.i32.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _lrintf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i32 @llvm.lrint.i32.f32(float %0)
  ret i32 %2
}
declare i32 @llvm.lrint.i32.f64(float)
define i32 @lrint.i32.f64(float) {
; Z80-LABEL: lrint.i32.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _lrintf
; Z80-NEXT:    pop iy
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lrint.i32.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _lrintf
; EZ80-CODE16-NEXT:    ld iy, 4
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld sp, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lrint.i32.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _lrintf
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i32 @llvm.lrint.i32.f64(float %0)
  ret i32 %2
}

declare i64 @llvm.llrint.i64.f32(float)
define i64 @llrint.i64.f32(float) {
; Z80-LABEL: llrint.i64.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _llrint
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: llrint.i64.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _llrint
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: llrint.i64.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _llrint
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i64 @llvm.llrint.i64.f32(float %0)
  ret i64 %2
}
declare i64 @llvm.llrint.i64.f64(float)
define i64 @llrint.i64.f64(float) {
; Z80-LABEL: llrint.i64.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    push de
; Z80-NEXT:    push hl
; Z80-NEXT:    call _llrint
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: llrint.i64.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    call _llrint
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: llrint.i64.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    call _llrint
; EZ80-NEXT:    ld iy, 6
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ret
  call i64 @llvm.llrint.i64.f64(float %0)
  ret i64 %2
}

declare float @llvm.canonicalize.f32(float)
define float @canonicalize.f32(float) {
; Z80-LABEL: canonicalize.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: canonicalize.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: canonicalize.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ret
  call float @llvm.canonicalize.f32(float %0)
  ret float %2
}
declare double @llvm.canonicalize.f64(double)
define double @canonicalize.f64(double) {
; Z80-LABEL: canonicalize.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: canonicalize.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: canonicalize.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  call double @llvm.canonicalize.f64(double %0)
  ret double %2
}

declare float @llvm.fmuladd.f32(float, float, float)
define float @fmuladd.f32(float, float, float) {
; Z80-LABEL: fmuladd.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    call __fmul
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ld e, (ix + 14)
; Z80-NEXT:    ld d, (ix + 15)
; Z80-NEXT:    call __fadd
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fmuladd.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    call __fmul
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    ld de, (ix + 14)
; EZ80-CODE16-NEXT:    call __fadd
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fmuladd.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 6)
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld hl, (ix + 12)
; EZ80-NEXT:    ld e, (ix + 15)
; EZ80-NEXT:    ld iy, (ix + 18)
; EZ80-NEXT:    ld d, (ix + 21)
; EZ80-NEXT:    call __fmul
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    ld e, d
; EZ80-NEXT:    call __fadd
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call float @llvm.fmuladd.f32(float %0, float %1, float %2)
  ret float %4
}
declare double @llvm.fmuladd.f64(double, double, double)
define double @fmuladd.f64(double, double, double) {
; Z80-LABEL: fmuladd.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __dmul
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix + 26)
; Z80-NEXT:    ld h, (ix + 27)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 24)
; Z80-NEXT:    ld h, (ix + 25)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 22)
; Z80-NEXT:    ld h, (ix + 23)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 20)
; Z80-NEXT:    ld h, (ix + 21)
; Z80-NEXT:    push hl
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    call __dadd
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fmuladd.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __dmul
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 26)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 24)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 22)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 20)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    call __dadd
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fmuladd.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dmul
; EZ80-NEXT:    ld iy, 9
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld sp, iy
; EZ80-NEXT:    ld iy, (ix + 30)
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld iy, (ix + 27)
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld iy, (ix + 24)
; EZ80-NEXT:    push iy
; EZ80-NEXT:    call __dadd
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  call double @llvm.fmuladd.f64(double %0, double %1, double %2)
  ret double %4
}

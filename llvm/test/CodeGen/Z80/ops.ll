; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=z80 < %s | FileCheck %s --check-prefixes=Z80
; RUN: llc -mtriple=ez80-code16 < %s | FileCheck %s --check-prefixes=EZ80-CODE16
; RUN: llc -mtriple=ez80 < %s | FileCheck %s --check-prefixes=EZ80

define void @ret.void() {
; Z80-LABEL: ret.void:
; Z80:       ; %bb.0:
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.void:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.void:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ret
  ret void
}
define i8 @ret.i8(i8) {
; Z80-LABEL: ret.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ret
  ret i8 %0
}
define i16 @ret.i16(i16) {
; Z80-LABEL: ret.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  ret i16 %0
}
define i24 @ret.i24(i24) {
; Z80-LABEL: ret.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, (iy + 4)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  ret i24 %0
}
define i32 @ret.i32(i32) {
; Z80-LABEL: ret.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ret
  ret i32 %0
}
define i48 @ret.i48(i48) {
; Z80-LABEL: ret.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ret
  ret i48 %0
}
define i64 @ret.i64(i64) {
; Z80-LABEL: ret.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  ret i64 %0
}
define float @ret.f32(float) {
; Z80-LABEL: ret.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ret
  ret float %0
}
define double @ret.f64(double) {
; Z80-LABEL: ret.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ret.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ret.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  ret double %0
}

define void @br() {
; Z80-LABEL: br:
; Z80:       ; %bb.0:
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: br:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: br:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ret
  br label %1
  ret void
}
define i8 @br.i1(i1) {
; Z80-LABEL: br.i1:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, 0
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    xor a, 1
; Z80-NEXT:    bit 0, a
; Z80-NEXT:    jr nz, BB10_2
; Z80-NEXT:  ; %bb.1:
; Z80-NEXT:    ld a, 1
; Z80-NEXT:    ret
; Z80-NEXT:  BB10_2:
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: br.i1:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, 0
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    xor a, 1
; EZ80-CODE16-NEXT:    bit 0, a
; EZ80-CODE16-NEXT:    jr nz, BB10_2
; EZ80-CODE16-NEXT:  ; %bb.1:
; EZ80-CODE16-NEXT:    ld a, 1
; EZ80-CODE16-NEXT:    ret
; EZ80-CODE16-NEXT:  BB10_2:
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: br.i1:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld l, 0
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    xor a, 1
; EZ80-NEXT:    bit 0, a
; EZ80-NEXT:    jr nz, BB10_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld a, 1
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB10_2:
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  br i1 %0, label %2, label %3
  ret i8 1
  ret i8 0
}

define i8 @switch(i8) {
; Z80-LABEL: switch:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, 0
; Z80-NEXT:    ld a, e
; Z80-NEXT:    cp a, 4
; Z80-NEXT:    jr c, BB11_2
; Z80-NEXT:  ; %bb.1:
; Z80-NEXT:    ld a, -1
; Z80-NEXT:    ret
; Z80-NEXT:  BB11_2:
; Z80-NEXT:    ld hl, JTI11_0
; Z80-NEXT:    add hl, de
; Z80-NEXT:    add hl, de
; Z80-NEXT:    push de
; Z80-NEXT:    ld e, (hl)
; Z80-NEXT:    inc hl
; Z80-NEXT:    ld d, (hl)
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    pop de
; Z80-NEXT:    jp (hl)
; Z80-NEXT:  BB11_3:
; Z80-NEXT:    ld a, d
; Z80-NEXT:    ret
; Z80-NEXT:  BB11_4:
; Z80-NEXT:    ld a, 2
; Z80-NEXT:    ret
; Z80-NEXT:  BB11_5:
; Z80-NEXT:    ld a, 3
; Z80-NEXT:    ret
; Z80-NEXT:  BB11_6:
; Z80-NEXT:    ld a, 1
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: switch:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld e, (iy + 2)
; EZ80-CODE16-NEXT:    ld d, 0
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    cp a, 4
; EZ80-CODE16-NEXT:    jr c, BB11_2
; EZ80-CODE16-NEXT:  ; %bb.1:
; EZ80-CODE16-NEXT:    ld a, -1
; EZ80-CODE16-NEXT:    ret
; EZ80-CODE16-NEXT:  BB11_2:
; EZ80-CODE16-NEXT:    ld hl, JTI11_0
; EZ80-CODE16-NEXT:    add hl, de
; EZ80-CODE16-NEXT:    add hl, de
; EZ80-CODE16-NEXT:    ld hl, (hl)
; EZ80-CODE16-NEXT:    jp (hl)
; EZ80-CODE16-NEXT:  BB11_3:
; EZ80-CODE16-NEXT:    ld a, d
; EZ80-CODE16-NEXT:    ret
; EZ80-CODE16-NEXT:  BB11_4:
; EZ80-CODE16-NEXT:    ld a, 2
; EZ80-CODE16-NEXT:    ret
; EZ80-CODE16-NEXT:  BB11_5:
; EZ80-CODE16-NEXT:    ld a, 3
; EZ80-CODE16-NEXT:    ret
; EZ80-CODE16-NEXT:  BB11_6:
; EZ80-CODE16-NEXT:    ld a, 1
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: switch:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld c, 0
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    cp a, 4
; EZ80-NEXT:    jr c, BB11_2
; EZ80-NEXT:  ; %bb.1:
; EZ80-NEXT:    ld a, -1
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB11_2:
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ld hl, JTI11_0
; EZ80-NEXT:    add hl, de
; EZ80-NEXT:    add hl, de
; EZ80-NEXT:    add hl, de
; EZ80-NEXT:    ld hl, (hl)
; EZ80-NEXT:    jp (hl)
; EZ80-NEXT:  BB11_3:
; EZ80-NEXT:    ld a, c
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB11_4:
; EZ80-NEXT:    ld a, 2
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB11_5:
; EZ80-NEXT:    ld a, 3
; EZ80-NEXT:    ret
; EZ80-NEXT:  BB11_6:
; EZ80-NEXT:    ld a, 1
; EZ80-NEXT:    ret
  switch i8 %0, label %2 [ i8 0, label %3
                           i8 1, label %4
                           i8 2, label %5
                           i8 3, label %6 ]
  ret i8 -1
  ret i8 0
  ret i8 1
  ret i8 2
  ret i8 3
}

define i8 @indirectbr(i8*) {
; Z80-LABEL: indirectbr:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    xor a, a
; Z80-NEXT:    jp (hl)
; Z80-NEXT:  BB12_1:
; Z80-NEXT:    ld a, 1
; Z80-NEXT:  BB12_2:
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: indirectbr:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    xor a, a
; EZ80-CODE16-NEXT:    jp (hl)
; EZ80-CODE16-NEXT:  BB12_1:
; EZ80-CODE16-NEXT:    ld a, 1
; EZ80-CODE16-NEXT:  BB12_2:
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: indirectbr:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    xor a, a
; EZ80-NEXT:    jp (hl)
; EZ80-NEXT:  BB12_1:
; EZ80-NEXT:    ld a, 1
; EZ80-NEXT:  BB12_2:
; EZ80-NEXT:    ret
  indirectbr i8* %0, [label %2, label %3]
  ret i8 1
  ret i8 0
}

define i8 @shl.i8(i8, i8) {
; Z80-LABEL: shl.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld b, (iy + 4)
; Z80-NEXT:    call __bshl
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: shl.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld b, (iy + 4)
; EZ80-CODE16-NEXT:    call __bshl
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: shl.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld b, (iy + 6)
; EZ80-NEXT:    call __bshl
; EZ80-NEXT:    ret
  shl i8 %0, %1
  ret i8 %3
}
define i16 @shl.i16(i16, i16) {
; Z80-LABEL: shl.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    ; kill: def $c killed $c killed $bc
; Z80-NEXT:    call __sshl
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: shl.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    ; kill: def $c killed $c killed $bc
; EZ80-CODE16-NEXT:    call __sshl
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: shl.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __sshl
; EZ80-NEXT:    ret
  shl i16 %0, %1
  ret i16 %3
}
define i32 @shl.i32(i32, i32) {
; Z80-LABEL: shl.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    call __lshl
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: shl.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    call __lshl
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: shl.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    call __lshl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  shl i32 %0, %1
  ret i32 %3
}
define i64 @shl.i64(i64, i64) {
; Z80-LABEL: shl.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    push hl
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    call __llshl
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: shl.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    call __llshl
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: shl.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld iy, (iy + 12)
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llshl
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ret
  shl i64 %0, %1
  ret i64 %3
}

define i8 @lshr.i8(i8, i8) {
; Z80-LABEL: lshr.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld b, (iy + 4)
; Z80-NEXT:    call __bshru
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lshr.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld b, (iy + 4)
; EZ80-CODE16-NEXT:    call __bshru
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lshr.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld b, (iy + 6)
; EZ80-NEXT:    call __bshru
; EZ80-NEXT:    ret
  lshr i8 %0, %1
  ret i8 %3
}
define i16 @lshr.i16(i16, i16) {
; Z80-LABEL: lshr.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    ; kill: def $c killed $c killed $bc
; Z80-NEXT:    call __sshru
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lshr.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    ; kill: def $c killed $c killed $bc
; EZ80-CODE16-NEXT:    call __sshru
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lshr.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __sshru
; EZ80-NEXT:    ret
  lshr i16 %0, %1
  ret i16 %3
}
define i32 @lshr.i32(i32, i32) {
; Z80-LABEL: lshr.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    call __lshru
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lshr.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    call __lshru
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lshr.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    call __lshru
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  lshr i32 %0, %1
  ret i32 %3
}
define i64 @lshr.i64(i64, i64) {
; Z80-LABEL: lshr.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    push hl
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    call __llshru
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: lshr.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    call __llshru
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: lshr.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld iy, (iy + 12)
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llshru
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ret
  lshr i64 %0, %1
  ret i64 %3
}

define i8 @ashr.i8(i8, i8) {
; Z80-LABEL: ashr.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld b, (iy + 4)
; Z80-NEXT:    call __bshrs
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ashr.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld b, (iy + 4)
; EZ80-CODE16-NEXT:    call __bshrs
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ashr.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld b, (iy + 6)
; EZ80-NEXT:    call __bshrs
; EZ80-NEXT:    ret
  ashr i8 %0, %1
  ret i8 %3
}
define i16 @ashr.i16(i16, i16) {
; Z80-LABEL: ashr.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    ; kill: def $c killed $c killed $bc
; Z80-NEXT:    call __sshrs
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ashr.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    ; kill: def $c killed $c killed $bc
; EZ80-CODE16-NEXT:    call __sshrs
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ashr.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $c killed $c killed $ubc
; EZ80-NEXT:    call __sshrs
; EZ80-NEXT:    ret
  ashr i16 %0, %1
  ret i16 %3
}
define i32 @ashr.i32(i32, i32) {
; Z80-LABEL: ashr.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    call __lshrs
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ashr.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    call __lshrs
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ashr.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ; kill: def $l killed $l killed $uhl
; EZ80-NEXT:    call __lshrs
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  ashr i32 %0, %1
  ret i32 %3
}
define i64 @ashr.i64(i64, i64) {
; Z80-LABEL: ashr.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    push hl
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    call __llshrs
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ashr.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    ld hl, (ix + 12)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    call __llshrs
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 4
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ashr.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld iy, (iy + 12)
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llshrs
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    ret
  ashr i64 %0, %1
  ret i64 %3
}

define i8 @and.i8(i8, i8) {
; Z80-LABEL: and.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    and a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: and.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    and a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: and.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld l, (iy + 6)
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    and a, l
; EZ80-NEXT:    ret
  and i8 %0, %1
  ret i8 %3
}
define i16 @and.i16(i16, i16) {
; Z80-LABEL: and.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    and a, c
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld a, d
; Z80-NEXT:    and a, b
; Z80-NEXT:    ld h, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: and.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld de, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    and a, c
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld a, d
; EZ80-CODE16-NEXT:    and a, b
; EZ80-CODE16-NEXT:    ld h, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: and.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ld a, e
; EZ80-NEXT:    and a, c
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    and a, b
; EZ80-NEXT:    ld h, a
; EZ80-NEXT:    ret
  and i16 %0, %1
  ret i16 %3
}
define i32 @and.i32(i32, i32) {
; Z80-LABEL: and.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __land
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: and.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __land
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: and.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __land
; EZ80-NEXT:    ret
  and i32 %0, %1
  ret i32 %3
}
define i64 @and.i64(i64, i64) {
; Z80-LABEL: and.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __lland
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: and.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __lland
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: and.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lland
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  and i64 %0, %1
  ret i64 %3
}

define i8 @or.i8(i8, i8) {
; Z80-LABEL: or.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    or a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: or.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    or a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: or.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld l, (iy + 6)
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    or a, l
; EZ80-NEXT:    ret
  or i8 %0, %1
  ret i8 %3
}
define i16 @or.i16(i16, i16) {
; Z80-LABEL: or.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    or a, c
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld a, d
; Z80-NEXT:    or a, b
; Z80-NEXT:    ld h, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: or.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld de, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    or a, c
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld a, d
; EZ80-CODE16-NEXT:    or a, b
; EZ80-CODE16-NEXT:    ld h, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: or.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ld a, e
; EZ80-NEXT:    or a, c
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    or a, b
; EZ80-NEXT:    ld h, a
; EZ80-NEXT:    ret
  or i16 %0, %1
  ret i16 %3
}
define i32 @or.i32(i32, i32) {
; Z80-LABEL: or.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __lor
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: or.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __lor
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: or.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __lor
; EZ80-NEXT:    ret
  or i32 %0, %1
  ret i32 %3
}
define i64 @or.i64(i64, i64) {
; Z80-LABEL: or.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __llor
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: or.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __llor
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: or.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llor
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  or i64 %0, %1
  ret i64 %3
}

define i8 @xor.i8(i8, i8) {
; Z80-LABEL: xor.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    xor a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: xor.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    xor a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: xor.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld l, (iy + 6)
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    xor a, l
; EZ80-NEXT:    ret
  xor i8 %0, %1
  ret i8 %3
}
define i16 @xor.i16(i16, i16) {
; Z80-LABEL: xor.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    xor a, c
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld a, d
; Z80-NEXT:    xor a, b
; Z80-NEXT:    ld h, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: xor.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld de, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    xor a, c
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld a, d
; EZ80-CODE16-NEXT:    xor a, b
; EZ80-CODE16-NEXT:    ld h, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: xor.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ld a, e
; EZ80-NEXT:    xor a, c
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    xor a, b
; EZ80-NEXT:    ld h, a
; EZ80-NEXT:    ret
  xor i16 %0, %1
  ret i16 %3
}
define i32 @xor.i32(i32, i32) {
; Z80-LABEL: xor.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __lxor
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: xor.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __lxor
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: xor.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __lxor
; EZ80-NEXT:    ret
  xor i32 %0, %1
  ret i32 %3
}
define i64 @xor.i64(i64, i64) {
; Z80-LABEL: xor.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __llxor
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: xor.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __llxor
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: xor.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llxor
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  xor i64 %0, %1
  ret i64 %3
}

define i8 @add.i8(i8, i8) {
; Z80-LABEL: add.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    add a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: add.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    add a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: add.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld l, (iy + 6)
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    add a, l
; EZ80-NEXT:    ret
  add i8 %0, %1
  ret i8 %3
}
define i16 @add.i16(i16, i16) {
; Z80-LABEL: add.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    add hl, de
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: add.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    add hl, de
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: add.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    add.sis hl, de
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  add i16 %0, %1
  ret i16 %3
}
define i32 @add.i32(i32, i32) {
; Z80-LABEL: add.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ladd
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: add.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __ladd
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: add.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __ladd
; EZ80-NEXT:    ret
  add i32 %0, %1
  ret i32 %3
}
define i48 @add.i48(i48, i48) {
; Z80-LABEL: add.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    ld c, (ix + 12)
; Z80-NEXT:    ld b, (ix + 13)
; Z80-NEXT:    add iy, de
; Z80-NEXT:    adc hl, bc
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    adc hl, bc
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, iyl
; Z80-NEXT:    ld d, iyh
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: add.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld iy, (ix + 4)
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    ld bc, (ix + 12)
; EZ80-CODE16-NEXT:    add iy, de
; EZ80-CODE16-NEXT:    adc hl, bc
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    adc hl, bc
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    lea hl, iy
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: add.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld iy, (ix + 6)
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    ld de, (ix + 12)
; EZ80-NEXT:    ld bc, (ix + 15)
; EZ80-NEXT:    add iy, de
; EZ80-NEXT:    adc hl, bc
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  add i48 %0, %1
  ret i48 %3
}
define i64 @add.i64(i64, i64) {
; Z80-LABEL: add.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __lladd
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: add.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __lladd
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: add.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lladd
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  add i64 %0, %1
  ret i64 %3
}

define i8 @sub.i8(i8, i8) {
; Z80-LABEL: sub.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    sub a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sub.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    sub a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sub.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld l, (iy + 6)
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sub a, l
; EZ80-NEXT:    ret
  sub i8 %0, %1
  ret i8 %3
}
define i16 @sub.i16(i16, i16) {
; Z80-LABEL: sub.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    sbc hl, de
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sub.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    sbc hl, de
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sub.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    sbc.sis hl, de
; EZ80-NEXT:    ret
  sub i16 %0, %1
  ret i16 %3
}
define i32 @sub.i32(i32, i32) {
; Z80-LABEL: sub.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __lsub
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sub.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __lsub
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sub.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __lsub
; EZ80-NEXT:    ret
  sub i32 %0, %1
  ret i32 %3
}
define i48 @sub.i48(i48, i48) {
; Z80-LABEL: sub.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    ld c, (ix + 12)
; Z80-NEXT:    ld b, (ix + 13)
; Z80-NEXT:    sbc hl, de
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    sbc hl, bc
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    sbc hl, bc
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, iyl
; Z80-NEXT:    ld d, iyh
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sub.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    ld bc, (ix + 12)
; EZ80-CODE16-NEXT:    sbc hl, de
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    sbc hl, bc
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    sbc hl, bc
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    lea hl, iy
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sub.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld iy, (ix + 9)
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld de, (ix + 15)
; EZ80-NEXT:    sbc hl, bc
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    lea hl, iy
; EZ80-NEXT:    sbc hl, de
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  sub i48 %0, %1
  ret i48 %3
}
define i64 @sub.i64(i64, i64) {
; Z80-LABEL: sub.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __llsub
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sub.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __llsub
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sub.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llsub
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  sub i64 %0, %1
  ret i64 %3
}

define i8 @mul.i8(i8, i8) {
; Z80-LABEL: mul.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld b, (iy + 2)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    call __bmulu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: mul.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld h, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    mlt hl
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: mul.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld h, (iy + 3)
; EZ80-NEXT:    ld l, (iy + 6)
; EZ80-NEXT:    mlt hl
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  mul i8 %0, %1
  ret i8 %3
}
define i16 @mul.i16(i16, i16) {
; Z80-LABEL: mul.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    call __smulu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: mul.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    call __smulu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: mul.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __smulu
; EZ80-NEXT:    ret
  mul i16 %0, %1
  ret i16 %3
}
define i32 @mul.i32(i32, i32) {
; Z80-LABEL: mul.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __lmulu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: mul.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __lmulu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: mul.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __lmulu
; EZ80-NEXT:    ret
  mul i32 %0, %1
  ret i32 %3
}
define i64 @mul.i64(i64, i64) {
; Z80-LABEL: mul.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __llmulu
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: mul.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __llmulu
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: mul.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llmulu
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  mul i64 %0, %1
  ret i64 %3
}

define i8 @udiv.i8(i8, i8) {
; Z80-LABEL: udiv.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld b, (iy + 2)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    call __bdivu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: udiv.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld b, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, (iy + 4)
; EZ80-CODE16-NEXT:    call __bdivu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: udiv.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld b, (iy + 3)
; EZ80-NEXT:    ld c, (iy + 6)
; EZ80-NEXT:    call __bdivu
; EZ80-NEXT:    ret
  udiv i8 %0, %1
  ret i8 %3
}
define i16 @udiv.i16(i16, i16) {
; Z80-LABEL: udiv.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    call __sdivu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: udiv.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    call __sdivu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: udiv.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __sdivu
; EZ80-NEXT:    ret
  udiv i16 %0, %1
  ret i16 %3
}
define i32 @udiv.i32(i32, i32) {
; Z80-LABEL: udiv.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ldivu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: udiv.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __ldivu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: udiv.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __ldivu
; EZ80-NEXT:    ret
  udiv i32 %0, %1
  ret i32 %3
}
define i64 @udiv.i64(i64, i64) {
; Z80-LABEL: udiv.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __lldivu
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: udiv.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __lldivu
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: udiv.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lldivu
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  udiv i64 %0, %1
  ret i64 %3
}

define i8 @sdiv.i8(i8, i8) {
; Z80-LABEL: sdiv.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld b, (iy + 2)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    call __bdivs
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sdiv.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld b, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, (iy + 4)
; EZ80-CODE16-NEXT:    call __bdivs
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sdiv.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld b, (iy + 3)
; EZ80-NEXT:    ld c, (iy + 6)
; EZ80-NEXT:    call __bdivs
; EZ80-NEXT:    ret
  sdiv i8 %0, %1
  ret i8 %3
}
define i16 @sdiv.i16(i16, i16) {
; Z80-LABEL: sdiv.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    call __sdivs
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sdiv.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    call __sdivs
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sdiv.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __sdivs
; EZ80-NEXT:    ret
  sdiv i16 %0, %1
  ret i16 %3
}
define i32 @sdiv.i32(i32, i32) {
; Z80-LABEL: sdiv.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ldivs
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sdiv.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __ldivs
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sdiv.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __ldivs
; EZ80-NEXT:    ret
  sdiv i32 %0, %1
  ret i32 %3
}
define i64 @sdiv.i64(i64, i64) {
; Z80-LABEL: sdiv.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __lldivs
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sdiv.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __lldivs
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sdiv.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lldivs
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  sdiv i64 %0, %1
  ret i64 %3
}

define i8 @urem.i8(i8, i8) {
; Z80-LABEL: urem.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    call __bremu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: urem.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, (iy + 4)
; EZ80-CODE16-NEXT:    call __bremu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: urem.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld c, (iy + 6)
; EZ80-NEXT:    call __bremu
; EZ80-NEXT:    ret
  urem i8 %0, %1
  ret i8 %3
}
define i16 @urem.i16(i16, i16) {
; Z80-LABEL: urem.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    call __sremu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: urem.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    call __sremu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: urem.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __sremu
; EZ80-NEXT:    ret
  urem i16 %0, %1
  ret i16 %3
}
define i32 @urem.i32(i32, i32) {
; Z80-LABEL: urem.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __lremu
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: urem.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __lremu
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: urem.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __lremu
; EZ80-NEXT:    ret
  urem i32 %0, %1
  ret i32 %3
}
define i64 @urem.i64(i64, i64) {
; Z80-LABEL: urem.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __llremu
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: urem.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __llremu
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: urem.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llremu
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  urem i64 %0, %1
  ret i64 %3
}

define i8 @srem.i8(i8, i8) {
; Z80-LABEL: srem.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    call __brems
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: srem.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, (iy + 4)
; EZ80-CODE16-NEXT:    call __brems
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: srem.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld c, (iy + 6)
; EZ80-NEXT:    call __brems
; EZ80-NEXT:    ret
  srem i8 %0, %1
  ret i8 %3
}
define i16 @srem.i16(i16, i16) {
; Z80-LABEL: srem.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld b, (iy + 5)
; Z80-NEXT:    call __srems
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: srem.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, (iy + 4)
; EZ80-CODE16-NEXT:    call __srems
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: srem.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, (iy + 6)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __srems
; EZ80-NEXT:    ret
  srem i16 %0, %1
  ret i16 %3
}
define i32 @srem.i32(i32, i32) {
; Z80-LABEL: srem.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __lrems
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: srem.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    call __lrems
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: srem.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ld a, (iy + 12)
; EZ80-NEXT:    call __lrems
; EZ80-NEXT:    ret
  srem i32 %0, %1
  ret i32 %3
}
define i64 @srem.i64(i64, i64) {
; Z80-LABEL: srem.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __llrems
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: srem.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __llrems
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: srem.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __llrems
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  srem i64 %0, %1
  ret i64 %3
}

define float @fneg.f32(float) {
; Z80-LABEL: fneg.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __fneg
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fneg.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __fneg
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fneg.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __fneg
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fneg float %0
  ret float %2
}
define double @fneg.f64(double) {
; Z80-LABEL: fneg.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dneg
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fneg.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dneg
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    pop hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fneg.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dneg
; EZ80-NEXT:    ret
  fneg double %0
  ret double %2
}

define float @fadd.f32(float, float) {
; Z80-LABEL: fadd.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    call __fadd
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fadd.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    call __fadd
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fadd.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ld e, (iy + 12)
; EZ80-NEXT:    call __fadd
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fadd float %0, %1
  ret float %3
}
define double @fadd.f64(double, double) {
; Z80-LABEL: fadd.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __dadd
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fadd.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __dadd
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fadd.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dadd
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  fadd double %0, %1
  ret double %3
}

define float @fsub.f32(float, float) {
; Z80-LABEL: fsub.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    call __fsub
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fsub.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    call __fsub
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fsub.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ld e, (iy + 12)
; EZ80-NEXT:    call __fsub
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fsub float %0, %1
  ret float %3
}
define double @fsub.f64(double, double) {
; Z80-LABEL: fsub.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __dsub
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fsub.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __dsub
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fsub.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dsub
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  fsub double %0, %1
  ret double %3
}

define float @fmul.f32(float, float) {
; Z80-LABEL: fmul.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    call __fmul
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fmul.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    call __fmul
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fmul.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ld e, (iy + 12)
; EZ80-NEXT:    call __fmul
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fmul float %0, %1
  ret float %3
}
define double @fmul.f64(double, double) {
; Z80-LABEL: fmul.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __dmul
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fmul.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __dmul
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fmul.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dmul
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  fmul double %0, %1
  ret double %3
}

define float @fdiv.f32(float, float) {
; Z80-LABEL: fdiv.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    call __fdiv
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fdiv.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    call __fdiv
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fdiv.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ld e, (iy + 12)
; EZ80-NEXT:    call __fdiv
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fdiv float %0, %1
  ret float %3
}
define double @fdiv.f64(double, double) {
; Z80-LABEL: fdiv.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __ddiv
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fdiv.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __ddiv
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fdiv.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __ddiv
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  fdiv double %0, %1
  ret double %3
}

define float @frem.f32(float, float) {
; Z80-LABEL: frem.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld c, (ix + 4)
; Z80-NEXT:    ld b, (ix + 5)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld e, (ix + 10)
; Z80-NEXT:    ld d, (ix + 11)
; Z80-NEXT:    call __frem
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: frem.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld bc, (ix + 4)
; EZ80-CODE16-NEXT:    ld iy, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld de, (ix + 10)
; EZ80-CODE16-NEXT:    call __frem
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: frem.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld hl, (iy + 9)
; EZ80-NEXT:    ld e, (iy + 12)
; EZ80-NEXT:    call __frem
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  frem float %0, %1
  ret float %3
}
define double @frem.f64(double, double) {
; Z80-LABEL: frem.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 12)
; Z80-NEXT:    ld h, (ix + 13)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ld c, (ix + 14)
; Z80-NEXT:    ld b, (ix + 15)
; Z80-NEXT:    ld e, (ix + 16)
; Z80-NEXT:    ld d, (ix + 17)
; Z80-NEXT:    ld l, (ix + 18)
; Z80-NEXT:    ld h, (ix + 19)
; Z80-NEXT:    push hl
; Z80-NEXT:    push de
; Z80-NEXT:    push bc
; Z80-NEXT:    push iy
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    call __drem
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    ld hl, 10
; Z80-NEXT:    add hl, sp
; Z80-NEXT:    ld sp, hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: frem.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld iy, (ix + 12)
; EZ80-CODE16-NEXT:    ld bc, (ix + 14)
; EZ80-CODE16-NEXT:    ld de, (ix + 16)
; EZ80-CODE16-NEXT:    ld hl, (ix + 18)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    push de
; EZ80-CODE16-NEXT:    push bc
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    ld hl, (ix + 10)
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    call __drem
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    ld hl, 10
; EZ80-CODE16-NEXT:    add hl, sp
; EZ80-CODE16-NEXT:    ld sp, hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: frem.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld bc, (ix + 12)
; EZ80-NEXT:    ld iy, (ix + 15)
; EZ80-NEXT:    ld de, (ix + 18)
; EZ80-NEXT:    ld hl, (ix + 21)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    push iy
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ld de, (ix + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __drem
; EZ80-NEXT:    ld sp, ix
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  frem double %0, %1
  ret double %3
}

define i8 @trunc.i16.i8(i16) {
; Z80-LABEL: trunc.i16.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i16.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i16.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ret
  trunc i16 %0 to i8
  ret i8 %2
}
define i8 @trunc.i24.i8(i24) {
; Z80-LABEL: trunc.i24.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i24.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i24.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ret
  trunc i24 %0 to i8
  ret i8 %2
}
define i8 @trunc.i32.i8(i32) {
; Z80-LABEL: trunc.i32.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i32.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i32.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  trunc i32 %0 to i8
  ret i8 %2
}
define i8 @trunc.i48.i8(i48) {
; Z80-LABEL: trunc.i48.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i48.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i48.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  trunc i48 %0 to i8
  ret i8 %2
}
define i8 @trunc.i64.i8(i64) {
; Z80-LABEL: trunc.i64.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i64.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i64.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  trunc i64 %0 to i8
  ret i8 %2
}
define i16 @trunc.i24.i16(i24) {
; Z80-LABEL: trunc.i24.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i24.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i24.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  trunc i24 %0 to i16
  ret i16 %2
}
define i16 @trunc.i32.i16(i32) {
; Z80-LABEL: trunc.i32.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i32.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i32.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  trunc i32 %0 to i16
  ret i16 %2
}
define i16 @trunc.i48.i16(i48) {
; Z80-LABEL: trunc.i48.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i48.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i48.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  trunc i48 %0 to i16
  ret i16 %2
}
define i16 @trunc.i64.i16(i64) {
; Z80-LABEL: trunc.i64.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i64.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i64.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  trunc i64 %0 to i16
  ret i16 %2
}
define i24 @trunc.i32.i24(i32) {
; Z80-LABEL: trunc.i32.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i32.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i32.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  trunc i32 %0 to i24
  ret i24 %2
}
define i24 @trunc.i48.i24(i48) {
; Z80-LABEL: trunc.i48.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i48.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i48.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  trunc i48 %0 to i24
  ret i24 %2
}
define i24 @trunc.i64.i24(i64) {
; Z80-LABEL: trunc.i64.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i64.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i64.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  trunc i64 %0 to i24
  ret i24 %2
}
define i32 @trunc.i48.i32(i48) {
; Z80-LABEL: trunc.i48.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i48.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i48.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ret
  trunc i48 %0 to i32
  ret i32 %2
}
define i32 @trunc.i64.i32(i64) {
; Z80-LABEL: trunc.i64.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i64.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i64.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ret
  trunc i64 %0 to i32
  ret i32 %2
}
define i48 @trunc.i64.i48(i64) {
; Z80-LABEL: trunc.i64.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: trunc.i64.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: trunc.i64.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ret
  trunc i64 %0 to i48
  ret i48 %2
}

define i16 @zext.i8.i16(i8) {
; Z80-LABEL: zext.i8.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i8.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i8.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld h, 0
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  zext i8 %0 to i16
  ret i16 %2
}
define i24 @zext.i8.i24(i8) {
; Z80-LABEL: zext.i8.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    xor a, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i8.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    xor a, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i8.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  zext i8 %0 to i24
  ret i24 %2
}
define i32 @zext.i8.i32(i8) {
; Z80-LABEL: zext.i8.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld de, 0
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i8.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld de, 0
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i8.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    ret
  zext i8 %0 to i32
  ret i32 %2
}
define i48 @zext.i8.i48(i8) {
; Z80-LABEL: zext.i8.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i8.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i8.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ret
  zext i8 %0 to i48
  ret i48 %2
}
define i64 @zext.i8.i64(i8) {
; Z80-LABEL: zext.i8.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i8.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i8.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ld.sis bc, 0
; EZ80-NEXT:    ret
  zext i8 %0 to i64
  ret i64 %2
}
define i24 @zext.i16.i24(i16) {
; Z80-LABEL: zext.i16.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    xor a, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i16.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    xor a, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i16.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ret
  zext i16 %0 to i24
  ret i24 %2
}
define i32 @zext.i16.i32(i16) {
; Z80-LABEL: zext.i16.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld de, 0
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i16.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, 0
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i16.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    ret
  zext i16 %0 to i32
  ret i32 %2
}
define i48 @zext.i16.i48(i16) {
; Z80-LABEL: zext.i16.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i16.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i16.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ret
  zext i16 %0 to i48
  ret i48 %2
}
define i64 @zext.i16.i64(i16) {
; Z80-LABEL: zext.i16.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i16.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i16.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ld.sis bc, 0
; EZ80-NEXT:    ret
  zext i16 %0 to i64
  ret i64 %2
}
define i32 @zext.i24.i32(i24) {
; Z80-LABEL: zext.i24.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, (iy + 4)
; Z80-NEXT:    ld d, 0
; Z80-NEXT:    ld e, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i24.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, (iy + 4)
; EZ80-CODE16-NEXT:    ld d, 0
; EZ80-CODE16-NEXT:    ld e, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i24.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    ret
  zext i24 %0 to i32
  ret i32 %2
}
define i48 @zext.i24.i48(i24) {
; Z80-LABEL: zext.i24.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, (iy + 4)
; Z80-NEXT:    ld d, 0
; Z80-NEXT:    ld e, a
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i24.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, (iy + 4)
; EZ80-CODE16-NEXT:    ld d, 0
; EZ80-CODE16-NEXT:    ld e, a
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i24.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ret
  zext i24 %0 to i48
  ret i48 %2
}
define i64 @zext.i24.i64(i24) {
; Z80-LABEL: zext.i24.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, (iy + 4)
; Z80-NEXT:    ld d, 0
; Z80-NEXT:    ld e, a
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i24.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, (iy + 4)
; EZ80-CODE16-NEXT:    ld d, 0
; EZ80-CODE16-NEXT:    ld e, a
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i24.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ld.sis bc, 0
; EZ80-NEXT:    ret
  zext i24 %0 to i64
  ret i64 %2
}
define i48 @zext.i32.i48(i32) {
; Z80-LABEL: zext.i32.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i32.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i32.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  zext i32 %0 to i48
  ret i48 %2
}
define i64 @zext.i32.i64(i32) {
; Z80-LABEL: zext.i32.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i32.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i32.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ld.sis bc, 0
; EZ80-NEXT:    ret
  zext i32 %0 to i64
  ret i64 %2
}
define i64 @zext.i48.i64(i48) {
; Z80-LABEL: zext.i48.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: zext.i48.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: zext.i48.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld.sis bc, 0
; EZ80-NEXT:    ret
  zext i48 %0 to i64
  ret i64 %2
}

define i16 @sext.i8.i16(i8) {
; Z80-LABEL: sext.i8.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld a, e
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld h, a
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i8.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld e, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld h, a
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i8.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld e, (iy + 3)
; EZ80-NEXT:    ld a, e
; EZ80-NEXT:    rlc a
; EZ80-NEXT:    sbc a, a
; EZ80-NEXT:    ld h, a
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ret
  sext i8 %0 to i16
  ret i16 %2
}
define i24 @sext.i8.i24(i8) {
; Z80-LABEL: sext.i8.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld a, c
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i8.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld a, c
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i8.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  sext i8 %0 to i24
  ret i24 %2
}
define i32 @sext.i8.i32(i8) {
; Z80-LABEL: sext.i8.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld b, a
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i8.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld b, a
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i8.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    ret
  sext i8 %0 to i32
  ret i32 %2
}
define i48 @sext.i8.i48(i8) {
; Z80-LABEL: sext.i8.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i8.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i8.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  sext i8 %0 to i48
  ret i48 %2
}
define i64 @sext.i8.i64(i8) {
; Z80-LABEL: sext.i8.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i8.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i8.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  sext i8 %0 to i64
  ret i64 %2
}
define i24 @sext.i16.i24(i16) {
; Z80-LABEL: sext.i16.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, (iy + 3)
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld a, c
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i16.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld de, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld a, c
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i16.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld h, a
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ret
  sext i16 %0 to i24
  ret i24 %2
}
define i32 @sext.i16.i32(i16) {
; Z80-LABEL: sext.i16.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i16.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i16.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    ret
  sext i16 %0 to i32
  ret i32 %2
}
define i48 @sext.i16.i48(i16) {
; Z80-LABEL: sext.i16.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, (iy + 3)
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i16.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld de, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i16.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  sext i16 %0 to i48
  ret i48 %2
}
define i64 @sext.i16.i64(i16) {
; Z80-LABEL: sext.i16.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld e, (iy + 2)
; Z80-NEXT:    ld d, (iy + 3)
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i16.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld de, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i16.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, b
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ld d, a
; EZ80-NEXT:    ld e, c
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  sext i16 %0 to i64
  ret i64 %2
}
define i32 @sext.i24.i32(i24) {
; Z80-LABEL: sext.i24.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld a, c
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i24.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, c
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i24.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    ret
  sext i24 %0 to i32
  ret i32 %2
}
define i48 @sext.i24.i48(i24) {
; Z80-LABEL: sext.i24.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i24.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld l, (ix + 6)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i24.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  sext i24 %0 to i48
  ret i48 %2
}
define i64 @sext.i24.i64(i24) {
; Z80-LABEL: sext.i24.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld l, e
; Z80-NEXT:    ld h, d
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld c, iyl
; Z80-NEXT:    ld b, iyh
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i24.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld l, e
; EZ80-CODE16-NEXT:    ld h, d
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    lea bc, iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i24.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ex de, hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  sext i24 %0 to i64
  ret i64 %2
}
define i48 @sext.i32.i48(i32) {
; Z80-LABEL: sext.i32.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i32.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i32.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  sext i32 %0 to i48
  ret i48 %2
}
define i64 @sext.i32.i64(i32) {
; Z80-LABEL: sext.i32.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld l, (ix + 6)
; Z80-NEXT:    ld h, (ix + 7)
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i32.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld hl, (ix + 6)
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i32.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld a, (ix + 9)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  sext i32 %0 to i64
  ret i64 %2
}
define i64 @sext.i48.i64(i48) {
; Z80-LABEL: sext.i48.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld l, (ix + 8)
; Z80-NEXT:    ld h, (ix + 9)
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sext.i48.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld hl, (ix + 8)
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sext.i48.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    push ix
; EZ80-NEXT:    ld ix, 0
; EZ80-NEXT:    add ix, sp
; EZ80-NEXT:    ld hl, (ix + 9)
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push de
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld hl, (ix + 6)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    pop ix
; EZ80-NEXT:    ret
  sext i48 %0 to i64
  ret i64 %2
}

define float @fptrunc.f64.f32(double) {
; Z80-LABEL: fptrunc.f64.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtof
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptrunc.f64.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtof
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptrunc.f64.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtof
; EZ80-NEXT:    ret
  fptrunc double %0 to float
  ret float %2
}

define double @fpext.f32.f64(float) {
; Z80-LABEL: fpext.f32.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    call __ftod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fpext.f32.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fpext.f32.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    call __ftod
; EZ80-NEXT:    ret
  fpext float %0 to double
  ret double %2
}

define i8 @fptoui.f32.i8(float) {
; Z80-LABEL: fptoui.f32.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftoul
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f32.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftoul
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f32.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftoul
; EZ80-NEXT:    ld a, c
; EZ80-NEXT:    ret
  fptoui float %0 to i8
  ret i8 %2
}
define i16 @fptoui.f32.i16(float) {
; Z80-LABEL: fptoui.f32.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftoul
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f32.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftoul
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f32.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftoul
; EZ80-NEXT:    ld l, c
; EZ80-NEXT:    ld h, b
; EZ80-NEXT:    ret
  fptoui float %0 to i16
  ret i16 %2
}
define i24 @fptoui.f32.i24(float) {
; Z80-LABEL: fptoui.f32.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftoul
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f32.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftoul
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f32.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftoul
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  fptoui float %0 to i24
  ret i24 %2
}
define i32 @fptoui.f32.i32(float) {
; Z80-LABEL: fptoui.f32.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftoul
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f32.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftoul
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f32.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftoul
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fptoui float %0 to i32
  ret i32 %2
}
define i64 @fptoui.f32.i64(float) {
; Z80-LABEL: fptoui.f32.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    call __ftoull
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f32.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftoull
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f32.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    call __ftoull
; EZ80-NEXT:    ret
  fptoui float %0 to i64
  ret i64 %2
}
define i8 @fptoui.f64.i8(double) {
; Z80-LABEL: fptoui.f64.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtoul
; Z80-NEXT:    pop de
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f64.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtoul
; EZ80-CODE16-NEXT:    pop de
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f64.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtoul
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  fptoui double %0 to i8
  ret i8 %2
}
define i16 @fptoui.f64.i16(double) {
; Z80-LABEL: fptoui.f64.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtoul
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f64.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtoul
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f64.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtoul
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  fptoui double %0 to i16
  ret i16 %2
}
define i24 @fptoui.f64.i24(double) {
; Z80-LABEL: fptoui.f64.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtoul
; Z80-NEXT:    pop bc
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f64.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtoul
; EZ80-CODE16-NEXT:    pop bc
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f64.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtoul
; EZ80-NEXT:    ret
  fptoui double %0 to i24
  ret i24 %2
}
define i32 @fptoui.f64.i32(double) {
; Z80-LABEL: fptoui.f64.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtoul
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f64.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtoul
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f64.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtoul
; EZ80-NEXT:    ret
  fptoui double %0 to i32
  ret i32 %2
}
define i64 @fptoui.f64.i64(double) {
; Z80-LABEL: fptoui.f64.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtoull
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptoui.f64.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtoull
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    pop hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptoui.f64.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtoull
; EZ80-NEXT:    ret
  fptoui double %0 to i64
  ret i64 %2
}

define i8 @fptosi.f32.i8(float) {
; Z80-LABEL: fptosi.f32.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftol
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f32.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftol
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f32.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftol
; EZ80-NEXT:    ld a, c
; EZ80-NEXT:    ret
  fptosi float %0 to i8
  ret i8 %2
}
define i16 @fptosi.f32.i16(float) {
; Z80-LABEL: fptosi.f32.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftol
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f32.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftol
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f32.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftol
; EZ80-NEXT:    ld l, c
; EZ80-NEXT:    ld h, b
; EZ80-NEXT:    ret
  fptosi float %0 to i16
  ret i16 %2
}
define i24 @fptosi.f32.i24(float) {
; Z80-LABEL: fptosi.f32.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftol
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f32.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftol
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f32.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftol
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ret
  fptosi float %0 to i24
  ret i24 %2
}
define i32 @fptosi.f32.i32(float) {
; Z80-LABEL: fptosi.f32.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ftol
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f32.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftol
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f32.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ftol
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  fptosi float %0 to i32
  ret i32 %2
}
define i64 @fptosi.f32.i64(float) {
; Z80-LABEL: fptosi.f32.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    call __ftoll
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f32.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    call __ftoll
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f32.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    call __ftoll
; EZ80-NEXT:    ret
  fptosi float %0 to i64
  ret i64 %2
}
define i8 @fptosi.f64.i8(double) {
; Z80-LABEL: fptosi.f64.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtol
; Z80-NEXT:    pop de
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f64.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtol
; EZ80-CODE16-NEXT:    pop de
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f64.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtol
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  fptosi double %0 to i8
  ret i8 %2
}
define i16 @fptosi.f64.i16(double) {
; Z80-LABEL: fptosi.f64.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtol
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f64.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtol
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f64.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtol
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  fptosi double %0 to i16
  ret i16 %2
}
define i24 @fptosi.f64.i24(double) {
; Z80-LABEL: fptosi.f64.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtol
; Z80-NEXT:    pop bc
; Z80-NEXT:    ld a, e
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f64.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtol
; EZ80-CODE16-NEXT:    pop bc
; EZ80-CODE16-NEXT:    ld a, e
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f64.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtol
; EZ80-NEXT:    ret
  fptosi double %0 to i24
  ret i24 %2
}
define i32 @fptosi.f64.i32(double) {
; Z80-LABEL: fptosi.f64.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtol
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f64.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtol
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f64.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtol
; EZ80-NEXT:    ret
  fptosi double %0 to i32
  ret i32 %2
}
define i64 @fptosi.f64.i64(double) {
; Z80-LABEL: fptosi.f64.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __dtoll
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: fptosi.f64.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __dtoll
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    pop hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: fptosi.f64.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __dtoll
; EZ80-NEXT:    ret
  fptosi double %0 to i64
  ret i64 %2
}

define float @uitofp.i8.f32(i8) {
; Z80-LABEL: uitofp.i8.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld b, 0
; Z80-NEXT:    ld c, a
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    call __ultof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i8.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld b, 0
; EZ80-CODE16-NEXT:    ld c, a
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    call __ultof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i8.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld bc, 0
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    xor a, a
; EZ80-NEXT:    call __ultof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  uitofp i8 %0 to float
  ret float %2
}
define float @uitofp.i16.f32(i16) {
; Z80-LABEL: uitofp.i16.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    call __ultof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i16.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    call __ultof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i16.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld bc, 0
; EZ80-NEXT:    ld c, l
; EZ80-NEXT:    ld b, h
; EZ80-NEXT:    xor a, a
; EZ80-NEXT:    call __ultof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  uitofp i16 %0 to float
  ret float %2
}
define float @uitofp.i24.f32(i24) {
; Z80-LABEL: uitofp.i24.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    ld a, (iy + 4)
; Z80-NEXT:    ld iyh, 0
; Z80-NEXT:    ld iyl, a
; Z80-NEXT:    call __ultof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i24.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, (iy + 4)
; EZ80-CODE16-NEXT:    ld iyh, 0
; EZ80-CODE16-NEXT:    ld iyl, a
; EZ80-CODE16-NEXT:    call __ultof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i24.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    xor a, a
; EZ80-NEXT:    call __ultof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  uitofp i24 %0 to float
  ret float %2
}
define float @uitofp.i32.f32(i32) {
; Z80-LABEL: uitofp.i32.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ultof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i32.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ultof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i32.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ultof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  uitofp i32 %0 to float
  ret float %2
}
define float @uitofp.i64.f32(i64) {
; Z80-LABEL: uitofp.i64.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __ulltof
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i64.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __ulltof
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i64.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __ulltof
; EZ80-NEXT:    ret
  uitofp i64 %0 to float
  ret float %2
}
define double @uitofp.i8.f64(i8) {
; Z80-LABEL: uitofp.i8.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ld de, 0
; Z80-NEXT:    call __ultod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i8.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ld de, 0
; EZ80-CODE16-NEXT:    call __ultod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i8.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    call __ultod
; EZ80-NEXT:    ret
  uitofp i8 %0 to double
  ret double %2
}
define double @uitofp.i16.f64(i16) {
; Z80-LABEL: uitofp.i16.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld de, 0
; Z80-NEXT:    call __ultod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i16.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, 0
; EZ80-CODE16-NEXT:    call __ultod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i16.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    call __ultod
; EZ80-NEXT:    ret
  uitofp i16 %0 to double
  ret double %2
}
define double @uitofp.i24.f64(i24) {
; Z80-LABEL: uitofp.i24.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, (iy + 4)
; Z80-NEXT:    ld d, 0
; Z80-NEXT:    ld e, a
; Z80-NEXT:    call __ultod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i24.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, (iy + 4)
; EZ80-CODE16-NEXT:    ld d, 0
; EZ80-CODE16-NEXT:    ld e, a
; EZ80-CODE16-NEXT:    call __ultod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i24.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    call __ultod
; EZ80-NEXT:    ret
  uitofp i24 %0 to double
  ret double %2
}
define double @uitofp.i32.f64(i32) {
; Z80-LABEL: uitofp.i32.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    call __ultod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i32.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    call __ultod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i32.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    call __ultod
; EZ80-NEXT:    ret
  uitofp i32 %0 to double
  ret double %2
}
define double @uitofp.i64.f64(i64) {
; Z80-LABEL: uitofp.i64.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __ulltod
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: uitofp.i64.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __ulltod
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    pop hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: uitofp.i64.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __ulltod
; EZ80-NEXT:    ret
  uitofp i64 %0 to double
  ret double %2
}

define float @sitofp.i8.f32(i8) {
; Z80-LABEL: sitofp.i8.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld b, a
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    call __ltof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i8.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld b, a
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i8.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  sitofp i8 %0 to float
  ret float %2
}
define float @sitofp.i16.f32(i16) {
; Z80-LABEL: sitofp.i16.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld b, h
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ld iyh, d
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    call __ltof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i16.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld b, h
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ld iyh, d
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i16.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  sitofp i16 %0 to float
  ret float %2
}
define float @sitofp.i24.f32(i24) {
; Z80-LABEL: sitofp.i24.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld iyh, a
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    ld iyl, e
; Z80-NEXT:    ex de, hl
; Z80-NEXT:    call __ltof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i24.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld iyh, a
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    ld iyl, e
; EZ80-CODE16-NEXT:    ex de, hl
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i24.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  sitofp i24 %0 to float
  ret float %2
}
define float @sitofp.i32.f32(i32) {
; Z80-LABEL: sitofp.i32.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 4)
; Z80-NEXT:    ld h, (iy + 5)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    call __ltof
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i32.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld iy, (iy + 4)
; EZ80-CODE16-NEXT:    call __ltof
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i32.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    ld a, (iy + 6)
; EZ80-NEXT:    call __ltof
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ld e, a
; EZ80-NEXT:    ret
  sitofp i32 %0 to float
  ret float %2
}
define float @sitofp.i64.f32(i64) {
; Z80-LABEL: sitofp.i64.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __lltof
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i64.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __lltof
; EZ80-CODE16-NEXT:    pop iy
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i64.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lltof
; EZ80-NEXT:    ret
  sitofp i64 %0 to float
  ret float %2
}
define double @sitofp.i8.f64(i8) {
; Z80-LABEL: sitofp.i8.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld b, a
; Z80-NEXT:    ld c, l
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    call __ltod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i8.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld l, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld b, a
; EZ80-CODE16-NEXT:    ld c, l
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i8.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld c, a
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ret
  sitofp i8 %0 to double
  ret double %2
}
define double @sitofp.i16.f64(i16) {
; Z80-LABEL: sitofp.i16.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld c, (iy + 2)
; Z80-NEXT:    ld b, (iy + 3)
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    add iy, iy
; Z80-NEXT:    sbc hl, hl
; Z80-NEXT:    ld e, l
; Z80-NEXT:    ld d, h
; Z80-NEXT:    ld l, c
; Z80-NEXT:    ld h, b
; Z80-NEXT:    call __ltod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i16.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld bc, (iy + 2)
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    add iy, iy
; EZ80-CODE16-NEXT:    sbc hl, hl
; EZ80-CODE16-NEXT:    ld e, l
; EZ80-CODE16-NEXT:    ld d, h
; EZ80-CODE16-NEXT:    ld l, c
; EZ80-CODE16-NEXT:    ld h, b
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i16.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    ld a, d
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    rlc l
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop bc
; EZ80-NEXT:    ld b, a
; EZ80-NEXT:    ld c, e
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ret
  sitofp i16 %0 to double
  ret double %2
}
define double @sitofp.i24.f64(i24) {
; Z80-LABEL: sitofp.i24.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld c, (iy + 4)
; Z80-NEXT:    ld a, c
; Z80-NEXT:    rlc a
; Z80-NEXT:    sbc a, a
; Z80-NEXT:    ld d, a
; Z80-NEXT:    ld e, c
; Z80-NEXT:    call __ltod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i24.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld c, (iy + 4)
; EZ80-CODE16-NEXT:    ld a, c
; EZ80-CODE16-NEXT:    rlc a
; EZ80-CODE16-NEXT:    sbc a, a
; EZ80-CODE16-NEXT:    ld d, a
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i24.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld bc, (iy + 3)
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop iy
; EZ80-NEXT:    add iy, iy
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    push hl
; EZ80-NEXT:    pop de
; EZ80-NEXT:    push bc
; EZ80-NEXT:    pop hl
; EZ80-NEXT:    ; kill: def $e killed $e killed $ude
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ret
  sitofp i24 %0 to double
  ret double %2
}
define double @sitofp.i32.f64(i32) {
; Z80-LABEL: sitofp.i32.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    call __ltod
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i32.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    call __ltod
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i32.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    call __ltod
; EZ80-NEXT:    ret
  sitofp i32 %0 to double
  ret double %2
}
define double @sitofp.i64.f64(i64) {
; Z80-LABEL: sitofp.i64.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    push ix
; Z80-NEXT:    ld ix, 0
; Z80-NEXT:    add ix, sp
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 4)
; Z80-NEXT:    ld h, (ix + 5)
; Z80-NEXT:    ld e, (ix + 6)
; Z80-NEXT:    ld d, (ix + 7)
; Z80-NEXT:    ld c, (ix + 8)
; Z80-NEXT:    ld b, (ix + 9)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (ix + 10)
; Z80-NEXT:    ld h, (ix + 11)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    push iy
; Z80-NEXT:    call __lltod
; Z80-NEXT:    ld (ix - 2), l
; Z80-NEXT:    ld (ix - 1), h
; Z80-NEXT:    pop hl
; Z80-NEXT:    ld l, (ix - 2)
; Z80-NEXT:    ld h, (ix - 1)
; Z80-NEXT:    ld sp, ix
; Z80-NEXT:    pop ix
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: sitofp.i64.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    push ix
; EZ80-CODE16-NEXT:    ld ix, 0
; EZ80-CODE16-NEXT:    add ix, sp
; EZ80-CODE16-NEXT:    push hl
; EZ80-CODE16-NEXT:    ld hl, (ix + 4)
; EZ80-CODE16-NEXT:    ld de, (ix + 6)
; EZ80-CODE16-NEXT:    ld bc, (ix + 8)
; EZ80-CODE16-NEXT:    ld iy, (ix + 10)
; EZ80-CODE16-NEXT:    push iy
; EZ80-CODE16-NEXT:    call __lltod
; EZ80-CODE16-NEXT:    ld (ix - 2), hl
; EZ80-CODE16-NEXT:    pop hl
; EZ80-CODE16-NEXT:    ld hl, (ix - 2)
; EZ80-CODE16-NEXT:    ld sp, ix
; EZ80-CODE16-NEXT:    pop ix
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: sitofp.i64.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    call __lltod
; EZ80-NEXT:    ret
  sitofp i64 %0 to double
  ret double %2
}

define i8 @ptrtoint.i8(i8*) {
; Z80-LABEL: ptrtoint.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld a, l
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ptrtoint.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld a, l
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ptrtoint.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld a, l
; EZ80-NEXT:    ret
  ptrtoint i8* %0 to i8
  ret i8 %2
}
define i16 @ptrtoint.i16(i16*) {
; Z80-LABEL: ptrtoint.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ptrtoint.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ptrtoint.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ; kill: def $hl killed $hl killed $uhl
; EZ80-NEXT:    ret
  ptrtoint i16* %0 to i16
  ret i16 %2
}
define i24 @ptrtoint.i24(i24*) {
; Z80-LABEL: ptrtoint.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    xor a, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ptrtoint.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    xor a, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ptrtoint.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  ptrtoint i24* %0 to i24
  ret i24 %2
}
define i32 @ptrtoint.i32(i32*) {
; Z80-LABEL: ptrtoint.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld de, 0
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ptrtoint.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, 0
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ptrtoint.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, 0
; EZ80-NEXT:    ret
  ptrtoint i32* %0 to i32
  ret i32 %2
}
define i48 @ptrtoint.i48(i48*) {
; Z80-LABEL: ptrtoint.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ptrtoint.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ptrtoint.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ret
  ptrtoint i48* %0 to i48
  ret i48 %2
}
define i64 @ptrtoint.i64(i64*) {
; Z80-LABEL: ptrtoint.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld bc, 0
; Z80-NEXT:    ld e, c
; Z80-NEXT:    ld d, b
; Z80-NEXT:    ld iyl, c
; Z80-NEXT:    ld iyh, b
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: ptrtoint.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld bc, 0
; EZ80-CODE16-NEXT:    ld e, c
; EZ80-CODE16-NEXT:    ld d, b
; EZ80-CODE16-NEXT:    ld iyl, c
; EZ80-CODE16-NEXT:    ld iyh, b
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: ptrtoint.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, 0
; EZ80-NEXT:    ld.sis bc, 0
; EZ80-NEXT:    ret
  ptrtoint i64* %0 to i64
  ret i64 %2
}

define i8* @inttoptr.i8(i8) {
; Z80-LABEL: inttoptr.i8:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld a, (iy + 2)
; Z80-NEXT:    ld h, 0
; Z80-NEXT:    ld l, a
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: inttoptr.i8:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld a, (iy + 2)
; EZ80-CODE16-NEXT:    ld h, 0
; EZ80-CODE16-NEXT:    ld l, a
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: inttoptr.i8:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld a, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, a
; EZ80-NEXT:    ret
  inttoptr i8 %0 to i8*
  ret i8* %2
}
define i16* @inttoptr.i16(i16) {
; Z80-LABEL: inttoptr.i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: inttoptr.i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: inttoptr.i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld de, (iy + 3)
; EZ80-NEXT:    sbc hl, hl
; EZ80-NEXT:    ld l, e
; EZ80-NEXT:    ld h, d
; EZ80-NEXT:    ret
  inttoptr i16 %0 to i16*
  ret i16* %2
}
define i24* @inttoptr.i24(i24) {
; Z80-LABEL: inttoptr.i24:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: inttoptr.i24:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: inttoptr.i24:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  inttoptr i24 %0 to i24*
  ret i24* %2
}
define i32* @inttoptr.i32(i32) {
; Z80-LABEL: inttoptr.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: inttoptr.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: inttoptr.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  inttoptr i32 %0 to i32*
  ret i32* %2
}
define i48* @inttoptr.i48(i48) {
; Z80-LABEL: inttoptr.i48:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: inttoptr.i48:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: inttoptr.i48:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  inttoptr i48 %0 to i48*
  ret i48* %2
}
define i64* @inttoptr.i64(i64) {
; Z80-LABEL: inttoptr.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: inttoptr.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: inttoptr.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  inttoptr i64 %0 to i64*
  ret i64* %2
}

define i32 @bitcast.f32.i32(float) {
; Z80-LABEL: bitcast.f32.i32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: bitcast.f32.i32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: bitcast.f32.i32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ret
  bitcast float %0 to i32
  ret i32 %2
}
define i64 @bitcast.f64.i64(double) {
; Z80-LABEL: bitcast.f64.i64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: bitcast.f64.i64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: bitcast.f64.i64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  bitcast double %0 to i64
  ret i64 %2
}
define float @bitcast.i32.f32(i32) {
; Z80-LABEL: bitcast.i32.f32:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: bitcast.i32.f32:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: bitcast.i32.f32:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld e, (iy + 6)
; EZ80-NEXT:    ret
  bitcast i32 %0 to float
  ret float %2
}
define double @bitcast.i64.f64(i64) {
; Z80-LABEL: bitcast.i64.f64:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ld e, (iy + 4)
; Z80-NEXT:    ld d, (iy + 5)
; Z80-NEXT:    ld c, (iy + 6)
; Z80-NEXT:    ld b, (iy + 7)
; Z80-NEXT:    push hl
; Z80-NEXT:    ld l, (iy + 8)
; Z80-NEXT:    ld h, (iy + 9)
; Z80-NEXT:    ex (sp), hl
; Z80-NEXT:    pop iy
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: bitcast.i64.f64:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ld de, (iy + 4)
; EZ80-CODE16-NEXT:    ld bc, (iy + 6)
; EZ80-CODE16-NEXT:    ld iy, (iy + 8)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: bitcast.i64.f64:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ld de, (iy + 6)
; EZ80-NEXT:    ld bc, (iy + 9)
; EZ80-NEXT:    ; kill: def $bc killed $bc killed $ubc
; EZ80-NEXT:    ret
  bitcast i64 %0 to double
  ret double %2
}
define i16* @bitcast.p0i8.p0i16(i8*) {
; Z80-LABEL: bitcast.p0i8.p0i16:
; Z80:       ; %bb.0:
; Z80-NEXT:    ld iy, 0
; Z80-NEXT:    add iy, sp
; Z80-NEXT:    ld l, (iy + 2)
; Z80-NEXT:    ld h, (iy + 3)
; Z80-NEXT:    ret
;
; EZ80-CODE16-LABEL: bitcast.p0i8.p0i16:
; EZ80-CODE16:       ; %bb.0:
; EZ80-CODE16-NEXT:    ld iy, 0
; EZ80-CODE16-NEXT:    add iy, sp
; EZ80-CODE16-NEXT:    ld hl, (iy + 2)
; EZ80-CODE16-NEXT:    ret
;
; EZ80-LABEL: bitcast.p0i8.p0i16:
; EZ80:       ; %bb.0:
; EZ80-NEXT:    ld iy, 0
; EZ80-NEXT:    add iy, sp
; EZ80-NEXT:    ld hl, (iy + 3)
; EZ80-NEXT:    ret
  bitcast i8* %0 to i16*
  ret i16* %2
}
